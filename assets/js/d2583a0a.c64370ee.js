"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[7807],{3002(n,e,i){i.r(e),i.d(e,{assets:()=>a,contentTitle:()=>t,default:()=>m,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"module-3-digital-twin/chapter-2-robot-modeling/content","title":"URDF and SDF Robot Description Formats","description":"Learning Objectives","source":"@site/docs/module-3-digital-twin/chapter-2-robot-modeling/content.md","sourceDirName":"module-3-digital-twin/chapter-2-robot-modeling","slug":"/module-3-digital-twin/chapter-2-robot-modeling/content","permalink":"/Physicial_Ai_Book_Hackathon_1/docs/module-3-digital-twin/chapter-2-robot-modeling/content","draft":false,"unlisted":false,"editUrl":"https://github.com/shirazkk/Physicial_Ai_Book_Hackathon_1/edit/main/my-website/docs/module-3-digital-twin/chapter-2-robot-modeling/content.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Gazebo Simulation Environment Setup - Solutions","permalink":"/Physicial_Ai_Book_Hackathon_1/docs/module-3-digital-twin/chapter-1-gazebo-basics/solutions"},"next":{"title":"URDF and SDF Robot Description Formats - Exercises","permalink":"/Physicial_Ai_Book_Hackathon_1/docs/module-3-digital-twin/chapter-2-robot-modeling/exercises"}}');var s=i(4848),l=i(8453);const o={},t="URDF and SDF Robot Description Formats",a={},d=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Introduction",id:"introduction",level:2},{value:"1. Understanding URDF (Unified Robot Description Format)",id:"1-understanding-urdf-unified-robot-description-format",level:2},{value:"1.1 URDF Fundamentals",id:"11-urdf-fundamentals",level:3},{value:"1.2 Links and Their Properties",id:"12-links-and-their-properties",level:3},{value:"1.3 Joint Types and Constraints",id:"13-joint-types-and-constraints",level:3},{value:"2. Understanding SDF (Simulation Description Format)",id:"2-understanding-sdf-simulation-description-format",level:2},{value:"2.1 SDF Fundamentals",id:"21-sdf-fundamentals",level:3},{value:"2.2 SDF Extensions for Simulation",id:"22-sdf-extensions-for-simulation",level:3},{value:"3. Differences Between URDF and SDF",id:"3-differences-between-urdf-and-sdf",level:2},{value:"3.1 When to Use Each Format",id:"31-when-to-use-each-format",level:3},{value:"4. Best Practices for URDF with Xacro Macros",id:"4-best-practices-for-urdf-with-xacro-macros",level:2},{value:"4.1 Introduction to Xacro",id:"41-introduction-to-xacro",level:3},{value:"4.2 Advanced Xacro Techniques",id:"42-advanced-xacro-techniques",level:3},{value:"5. Creating Example Humanoid Robot URDF Model",id:"5-creating-example-humanoid-robot-urdf-model",level:2},{value:"6. Validating URDF Models",id:"6-validating-urdf-models",level:2},{value:"6.1 Using check_urdf Tool",id:"61-using-check_urdf-tool",level:3},{value:"6.2 Using urdf_tutorial",id:"62-using-urdf_tutorial",level:3},{value:"6.3 Common Validation Checks",id:"63-common-validation-checks",level:3},{value:"7. Joint Constraints and Physical Properties",id:"7-joint-constraints-and-physical-properties",level:2},{value:"7.1 Joint Limit Considerations",id:"71-joint-limit-considerations",level:3},{value:"7.2 Inertial Parameter Estimation",id:"72-inertial-parameter-estimation",level:3},{value:"7.3 Collision vs Visual Geometry",id:"73-collision-vs-visual-geometry",level:3},{value:"8. SDF Extensions for Simulation-Specific Features",id:"8-sdf-extensions-for-simulation-specific-features",level:2},{value:"8.1 Adding Sensors to URDF Models",id:"81-adding-sensors-to-urdf-models",level:3},{value:"8.2 Physics Properties in SDF",id:"82-physics-properties-in-sdf",level:3},{value:"9. Best Practices for Humanoid Robot Modeling",id:"9-best-practices-for-humanoid-robot-modeling",level:2},{value:"9.1 Proportional Design",id:"91-proportional-design",level:3},{value:"9.2 Center of Mass Considerations",id:"92-center-of-mass-considerations",level:3},{value:"9.3 Joint Configuration for Locomotion",id:"93-joint-configuration-for-locomotion",level:3},{value:"10. Summary",id:"10-summary",level:2},{value:"11. Exercises and Practice",id:"11-exercises-and-practice",level:2}];function c(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"urdf-and-sdf-robot-description-formats",children:"URDF and SDF Robot Description Formats"})}),"\n",(0,s.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsx)(e.p,{children:"By the end of this chapter, readers will be able to:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Understand the differences between URDF and SDF formats for robot description"}),"\n",(0,s.jsx)(e.li,{children:"Create accurate robot models using URDF with proper joint constraints and physical properties"}),"\n",(0,s.jsx)(e.li,{children:"Apply Xacro macros to simplify complex robot descriptions"}),"\n",(0,s.jsx)(e.li,{children:"Validate URDF models using standard tools"}),"\n",(0,s.jsx)(e.li,{children:"Extend robot models with SDF-specific features for simulation"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Completion of Module 1: Foundations of Physical AI & Humanoid Robotics"}),"\n",(0,s.jsx)(e.li,{children:"Completion of Module 2: Robotic Nervous System"}),"\n",(0,s.jsx)(e.li,{children:"Chapter 1: Gazebo Simulation Environment Setup"}),"\n",(0,s.jsx)(e.li,{children:"Understanding of coordinate systems and transformations"}),"\n",(0,s.jsx)(e.li,{children:"Basic knowledge of robot kinematics"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(e.p,{children:"Robot description formats are fundamental to robotics development, serving as blueprints that define a robot's physical structure, kinematic properties, and dynamic characteristics. In the ROS ecosystem, Unified Robot Description Format (URDF) is the standard for representing robot models, while Simulation Description Format (SDF) extends this concept specifically for simulation environments."}),"\n",(0,s.jsx)(e.p,{children:"This chapter explores both formats in depth, focusing on how to create accurate robot models with proper physical properties that enable realistic simulation and control. We'll examine best practices for humanoid robot modeling, emphasizing the importance of accurate inertial properties, joint constraints, and geometric representations."}),"\n",(0,s.jsx)(e.h2,{id:"1-understanding-urdf-unified-robot-description-format",children:"1. Understanding URDF (Unified Robot Description Format)"}),"\n",(0,s.jsx)(e.h3,{id:"11-urdf-fundamentals",children:"1.1 URDF Fundamentals"}),"\n",(0,s.jsx)(e.p,{children:"URDF is an XML-based format that describes robot models in terms of links, joints, and their relationships. A typical URDF model consists of:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Links"}),": Rigid bodies with mass, inertia, and geometric properties"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Joints"}),": Connections between links with defined motion constraints"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Materials"}),": Visual appearance definitions"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Transmissions"}),": Actuator interface specifications"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Gazebo plugins"}),": Simulation-specific extensions"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Here's a basic URDF structure:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_robot" xmlns:xacro="http://www.ros.org/wiki/xacro">\n  \x3c!-- Materials --\x3e\n  <material name="blue">\n    <color rgba="0.0 0.0 1.0 1.0"/>\n  </material>\n\n  \x3c!-- Base link --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <cylinder length="0.2" radius="0.1"/>\n      </geometry>\n      <material name="blue"/>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder length="0.2" radius="0.1"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1.0"/>\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.02"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Additional links and joints would follow --\x3e\n</robot>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"12-links-and-their-properties",children:"1.2 Links and Their Properties"}),"\n",(0,s.jsx)(e.p,{children:"Links represent rigid bodies in the robot model. Each link should include:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Visual"}),": Defines how the link appears in visualization tools"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Collision"}),": Defines the collision geometry for physics simulation"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Inertial"}),": Specifies mass properties for dynamic simulation"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Visual Properties:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<visual>\n  <origin xyz="0 0 0" rpy="0 0 0"/>\n  <geometry>\n    <box size="0.1 0.1 0.1"/>\n    \x3c!-- Other options: cylinder, sphere, mesh --\x3e\n  </geometry>\n  <material name="red_material"/>\n</visual>\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Collision Properties:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<collision>\n  <origin xyz="0 0 0" rpy="0 0 0"/>\n  <geometry>\n    <box size="0.1 0.1 0.1"/>\n  </geometry>\n</collision>\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Inertial Properties:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<inertial>\n  <origin xyz="0 0 0" rpy="0 0 0"/>\n  <mass value="0.5"/>\n  <inertia ixx="0.001" ixy="0.0" ixz="0.0" iyy="0.001" iyz="0.0" izz="0.001"/>\n</inertial>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"13-joint-types-and-constraints",children:"1.3 Joint Types and Constraints"}),"\n",(0,s.jsx)(e.p,{children:"Joints connect links and define their relative motion. URDF supports several joint types:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"revolute"}),": Rotational joint with limited range"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"continuous"}),": Rotational joint without limits"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"prismatic"}),": Linear sliding joint with limits"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"fixed"}),": No movement allowed"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"floating"}),": 6DOF motion (rarely used)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"planar"}),": Motion constrained to a plane"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Example joint definition:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<joint name="joint_name" type="revolute">\n  <parent link="parent_link"/>\n  <child link="child_link"/>\n  <origin xyz="0.1 0 0" rpy="0 0 0"/>\n  <axis xyz="0 0 1"/>\n  <limit lower="-1.57" upper="1.57" effort="10.0" velocity="1.0"/>\n  <dynamics damping="0.1" friction="0.0"/>\n</joint>\n'})}),"\n",(0,s.jsx)(e.h2,{id:"2-understanding-sdf-simulation-description-format",children:"2. Understanding SDF (Simulation Description Format)"}),"\n",(0,s.jsx)(e.h3,{id:"21-sdf-fundamentals",children:"2.1 SDF Fundamentals"}),"\n",(0,s.jsx)(e.p,{children:"While URDF is primarily used for robot description in ROS, SDF is specifically designed for Gazebo simulation. SDF can include URDF models but also provides additional simulation-specific features:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Plugins"}),": Custom simulation behaviors"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Sensors"}),": Detailed sensor configurations"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Physics parameters"}),": Advanced physics settings"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Visual effects"}),": Special rendering properties"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Basic SDF structure for a robot model:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<sdf version="1.7">\n  <model name="simple_robot">\n    <pose>0 0 0.5 0 0 0</pose>\n\n    \x3c!-- Links --\x3e\n    <link name="base_link">\n      <pose>0 0 0 0 0 0</pose>\n\n      \x3c!-- Visual properties --\x3e\n      <visual name="visual">\n        <geometry>\n          <box>\n            <size>0.1 0.1 0.1</size>\n          </box>\n        </geometry>\n      </visual>\n\n      \x3c!-- Collision properties --\x3e\n      <collision name="collision">\n        <geometry>\n          <box>\n            <size>0.1 0.1 0.1</size>\n          </box>\n        </geometry>\n      </collision>\n\n      \x3c!-- Inertial properties --\x3e\n      <inertial>\n        <mass>1.0</mass>\n        <inertia>\n          <ixx>0.001</ixx>\n          <ixy>0.0</ixy>\n          <ixz>0.0</ixz>\n          <iyy>0.001</iyy>\n          <iyz>0.0</iyz>\n          <izz>0.001</izz>\n        </inertia>\n      </inertial>\n    </link>\n\n    \x3c!-- Joints would follow --\x3e\n  </model>\n</sdf>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"22-sdf-extensions-for-simulation",children:"2.2 SDF Extensions for Simulation"}),"\n",(0,s.jsx)(e.p,{children:"SDF provides several extensions that are particularly useful for simulation:"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"SDF Models with Plugins:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<model name="sensor_equipped_robot">\n  \x3c!-- Include URDF model --\x3e\n  <include>\n    <uri>model://robot_model.urdf</uri>\n  </include>\n\n  \x3c!-- Add simulation plugins --\x3e\n  <plugin name="imu_sensor" filename="libgazebo_ros_imu.so">\n    <topic>imu/data</topic>\n    <serviceName>imu/service</serviceName>\n  </plugin>\n\n  \x3c!-- Custom controller plugin --\x3e\n  <plugin name="joint_controller" filename="libcustom_controller.so">\n    <robotNamespace>/my_robot</robotNamespace>\n  </plugin>\n</model>\n'})}),"\n",(0,s.jsx)(e.h2,{id:"3-differences-between-urdf-and-sdf",children:"3. Differences Between URDF and SDF"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Aspect"}),(0,s.jsx)(e.th,{children:"URDF"}),(0,s.jsx)(e.th,{children:"SDF"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Primary Use"})}),(0,s.jsx)(e.td,{children:"Robot description in ROS"}),(0,s.jsx)(e.td,{children:"Simulation in Gazebo"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Format"})}),(0,s.jsx)(e.td,{children:"XML"}),(0,s.jsx)(e.td,{children:"XML"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Geometry Support"})}),(0,s.jsx)(e.td,{children:"Box, Cylinder, Sphere, Mesh"}),(0,s.jsx)(e.td,{children:"Same + more advanced shapes"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Plugin Support"})}),(0,s.jsx)(e.td,{children:"Through Gazebo tags"}),(0,s.jsx)(e.td,{children:"Native plugin support"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Sensor Definitions"})}),(0,s.jsx)(e.td,{children:"Limited"}),(0,s.jsx)(e.td,{children:"Full sensor support"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Physics Extensions"})}),(0,s.jsx)(e.td,{children:"Basic"}),(0,s.jsx)(e.td,{children:"Advanced physics options"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Visualization"})}),(0,s.jsx)(e.td,{children:"Basic"}),(0,s.jsx)(e.td,{children:"Advanced rendering options"})]})]})]}),"\n",(0,s.jsx)(e.h3,{id:"31-when-to-use-each-format",children:"3.1 When to Use Each Format"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Use URDF when:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Defining robot structure for ROS"}),"\n",(0,s.jsx)(e.li,{children:"Working with MoveIt! or other ROS-based planning tools"}),"\n",(0,s.jsx)(e.li,{children:"Need compatibility with standard ROS tools"}),"\n",(0,s.jsx)(e.li,{children:"Describing robot for control purposes"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Use SDF when:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Creating simulation-specific models"}),"\n",(0,s.jsx)(e.li,{children:"Adding sensors and plugins"}),"\n",(0,s.jsx)(e.li,{children:"Defining world objects in Gazebo"}),"\n",(0,s.jsx)(e.li,{children:"Need advanced simulation features"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"4-best-practices-for-urdf-with-xacro-macros",children:"4. Best Practices for URDF with Xacro Macros"}),"\n",(0,s.jsx)(e.h3,{id:"41-introduction-to-xacro",children:"4.1 Introduction to Xacro"}),"\n",(0,s.jsx)(e.p,{children:"Xacro (XML Macros) extends URDF with features like variables, math expressions, and macros, making complex robot descriptions more manageable:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="xacro_robot">\n  \x3c!-- Define constants --\x3e\n  <xacro:property name="M_PI" value="3.1415926535897931" />\n  <xacro:property name="wheel_radius" value="0.05" />\n  <xacro:property name="wheel_width" value="0.02" />\n\n  \x3c!-- Define a macro for wheels --\x3e\n  <xacro:macro name="wheel" params="prefix parent xyz rpy *joint_origin *geometry">\n    <joint name="${prefix}_wheel_joint" type="continuous">\n      <xacro:insert_block name="joint_origin"/>\n      <parent link="${parent}"/>\n      <child link="${prefix}_wheel"/>\n      <axis xyz="0 1 0"/>\n    </joint>\n\n    <link name="${prefix}_wheel">\n      <xacro:insert_block name="geometry"/>\n      <inertial>\n        <mass value="0.1"/>\n        <inertia ixx="0.001" ixy="0.0" ixz="0.0" iyy="0.001" iyz="0.0" izz="0.001"/>\n      </inertial>\n    </link>\n  </xacro:macro>\n\n  \x3c!-- Use the macro to create wheels --\x3e\n  <xacro:wheel prefix="front_left" parent="base_link">\n    <origin xyz="0.2 0.1 0" rpy="0 0 0"/>\n    <geometry>\n      <cylinder radius="${wheel_radius}" length="${wheel_width}"/>\n    </geometry>\n  </xacro:wheel>\n</robot>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"42-advanced-xacro-techniques",children:"4.2 Advanced Xacro Techniques"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Conditional Statements:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<xacro:arg name="has_laser" default="false"/>\n\n<xacro:if value="$(arg has_laser)">\n  <link name="laser_link">\n    <visual>\n      <geometry>\n        <cylinder radius="0.02" length="0.05"/>\n      </geometry>\n    </visual>\n  </link>\n</xacro:if>\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Mathematical Expressions:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<xacro:property name="link_length" value="0.3" />\n<xacro:property name="half_length" value="${link_length / 2.0}" />\n\n<link name="arm_link">\n  <visual>\n    <origin xyz="0 0 ${half_length}" rpy="0 0 0"/>\n    <geometry>\n      <box size="0.05 0.05 ${link_length}"/>\n    </geometry>\n  </visual>\n</link>\n'})}),"\n",(0,s.jsx)(e.h2,{id:"5-creating-example-humanoid-robot-urdf-model",children:"5. Creating Example Humanoid Robot URDF Model"}),"\n",(0,s.jsx)(e.p,{children:"Let's create a simplified humanoid robot model:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_humanoid" xmlns:xacro="http://www.ros.org/wiki/xacro">\n  \x3c!-- Constants --\x3e\n  <xacro:property name="M_PI" value="3.1415926535897931"/>\n  <xacro:property name="mass_body" value="10.0"/>\n  <xacro:property name="mass_limb" value="2.0"/>\n  <xacro:property name="body_size_x" value="0.2"/>\n  <xacro:property name="body_size_y" value="0.15"/>\n  <xacro:property name="body_size_z" value="0.4"/>\n  <xacro:property name="limb_radius" value="0.05"/>\n  <xacro:property name="limb_length" value="0.3"/>\n\n  \x3c!-- Material definitions --\x3e\n  <material name="gray">\n    <color rgba="0.5 0.5 0.5 1.0"/>\n  </material>\n  <material name="white">\n    <color rgba="1.0 1.0 1.0 1.0"/>\n  </material>\n\n  \x3c!-- Base link - pelvis/torso --\x3e\n  <link name="base_link">\n    <visual>\n      <origin xyz="0 0 0" rpy="0 0 0"/>\n      <geometry>\n        <box size="${body_size_x} ${body_size_y} ${body_size_z}"/>\n      </geometry>\n      <material name="white"/>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0" rpy="0 0 0"/>\n      <geometry>\n        <box size="${body_size_x} ${body_size_y} ${body_size_z}"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="${mass_body}"/>\n      <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.1"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Head --\x3e\n  <joint name="neck_joint" type="revolute">\n    <parent link="base_link"/>\n    <child link="head_link"/>\n    <origin xyz="0 0 ${body_size_z/2 + 0.075}" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="${-M_PI/4}" upper="${M_PI/4}" effort="10.0" velocity="1.0"/>\n  </joint>\n\n  <link name="head_link">\n    <visual>\n      <geometry>\n        <sphere radius="0.075"/>\n      </geometry>\n      <material name="white"/>\n    </visual>\n    <collision>\n      <geometry>\n        <sphere radius="0.075"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1.0"/>\n      <inertia ixx="0.002" ixy="0.0" ixz="0.0" iyy="0.002" iyz="0.0" izz="0.002"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Left Arm --\x3e\n  <joint name="left_shoulder_pitch" type="revolute">\n    <parent link="base_link"/>\n    <child link="left_upper_arm"/>\n    <origin xyz="${body_size_x/2 + limb_radius} 0 ${body_size_z/4}" rpy="0 0 0"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="${-M_PI/2}" upper="${M_PI/2}" effort="10.0" velocity="1.0"/>\n  </joint>\n\n  <link name="left_upper_arm">\n    <visual>\n      <geometry>\n        <cylinder length="${limb_length}" radius="${limb_radius}"/>\n      </geometry>\n      <material name="gray"/>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder length="${limb_length}" radius="${limb_radius}"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="${mass_limb}"/>\n      <inertia ixx="0.02" ixy="0.0" ixz="0.0" iyy="0.02" iyz="0.0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  <joint name="left_elbow" type="revolute">\n    <parent link="left_upper_arm"/>\n    <child link="left_lower_arm"/>\n    <origin xyz="0 0 ${-limb_length/2}" rpy="0 0 0"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="${-M_PI/2}" upper="0" effort="10.0" velocity="1.0"/>\n  </joint>\n\n  <link name="left_lower_arm">\n    <visual>\n      <geometry>\n        <cylinder length="${limb_length}" radius="${limb_radius}"/>\n      </geometry>\n      <material name="gray"/>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder length="${limb_length}" radius="${limb_radius}"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="${mass_limb}"/>\n      <inertia ixx="0.02" ixy="0.0" ixz="0.0" iyy="0.02" iyz="0.0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Right Arm (mirror of left) --\x3e\n  <joint name="right_shoulder_pitch" type="revolute">\n    <parent link="base_link"/>\n    <child link="right_upper_arm"/>\n    <origin xyz="${-(body_size_x/2 + limb_radius)} 0 ${body_size_z/4}" rpy="0 0 0"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="${-M_PI/2}" upper="${M_PI/2}" effort="10.0" velocity="1.0"/>\n  </joint>\n\n  <link name="right_upper_arm">\n    <visual>\n      <geometry>\n        <cylinder length="${limb_length}" radius="${limb_radius}"/>\n      </geometry>\n      <material name="gray"/>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder length="${limb_length}" radius="${limb_radius}"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="${mass_limb}"/>\n      <inertia ixx="0.02" ixy="0.0" ixz="0.0" iyy="0.02" iyz="0.0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  <joint name="right_elbow" type="revolute">\n    <parent link="right_upper_arm"/>\n    <child link="right_lower_arm"/>\n    <origin xyz="0 0 ${-limb_length/2}" rpy="0 0 0"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="${-M_PI/2}" upper="0" effort="10.0" velocity="1.0"/>\n  </joint>\n\n  <link name="right_lower_arm">\n    <visual>\n      <geometry>\n        <cylinder length="${limb_length}" radius="${limb_radius}"/>\n      </geometry>\n      <material name="gray"/>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder length="${limb_length}" radius="${limb_radius}"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="${mass_limb}"/>\n      <inertia ixx="0.02" ixy="0.0" ixz="0.0" iyy="0.02" iyz="0.0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Left Leg --\x3e\n  <joint name="left_hip_pitch" type="revolute">\n    <parent link="base_link"/>\n    <child link="left_upper_leg"/>\n    <origin xyz="${body_size_x/4} 0 ${-body_size_z/2 - limb_radius}" rpy="0 0 0"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="${-M_PI/2}" upper="${M_PI/4}" effort="20.0" velocity="1.0"/>\n  </joint>\n\n  <link name="left_upper_leg">\n    <visual>\n      <geometry>\n        <cylinder length="${limb_length}" radius="${limb_radius}"/>\n      </geometry>\n      <material name="gray"/>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder length="${limb_length}" radius="${limb_radius}"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="${mass_limb}"/>\n      <inertia ixx="0.02" ixy="0.0" ixz="0.0" iyy="0.02" iyz="0.0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  <joint name="left_knee" type="revolute">\n    <parent link="left_upper_leg"/>\n    <child link="left_lower_leg"/>\n    <origin xyz="0 0 ${-limb_length/2}" rpy="0 0 0"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="${-M_PI/2}" upper="0" effort="20.0" velocity="1.0"/>\n  </joint>\n\n  <link name="left_lower_leg">\n    <visual>\n      <geometry>\n        <cylinder length="${limb_length}" radius="${limb_radius}"/>\n      </geometry>\n      <material name="gray"/>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder length="${limb_length}" radius="${limb_radius}"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="${mass_limb}"/>\n      <inertia ixx="0.02" ixy="0.0" ixz="0.0" iyy="0.02" iyz="0.0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Right Leg --\x3e\n  <joint name="right_hip_pitch" type="revolute">\n    <parent link="base_link"/>\n    <child link="right_upper_leg"/>\n    <origin xyz="${-body_size_x/4} 0 ${-body_size_z/2 - limb_radius}" rpy="0 0 0"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="${-M_PI/2}" upper="${M_PI/4}" effort="20.0" velocity="1.0"/>\n  </joint>\n\n  <link name="right_upper_leg">\n    <visual>\n      <geometry>\n        <cylinder length="${limb_length}" radius="${limb_radius}"/>\n      </geometry>\n      <material name="gray"/>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder length="${limb_length}" radius="${limb_radius}"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="${mass_limb}"/>\n      <inertia ixx="0.02" ixy="0.0" ixz="0.0" iyy="0.02" iyz="0.0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  <joint name="right_knee" type="revolute">\n    <parent link="right_upper_leg"/>\n    <child link="right_lower_leg"/>\n    <origin xyz="0 0 ${-limb_length/2}" rpy="0 0 0"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="${-M_PI/2}" upper="0" effort="20.0" velocity="1.0"/>\n  </joint>\n\n  <link name="right_lower_leg">\n    <visual>\n      <geometry>\n        <cylinder length="${limb_length}" radius="${limb_radius}"/>\n      </geometry>\n      <material name="gray"/>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder length="${limb_length}" radius="${limb_radius}"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="${mass_limb}"/>\n      <inertia ixx="0.02" ixy="0.0" ixz="0.0" iyy="0.02" iyz="0.0" izz="0.001"/>\n    </inertial>\n  </link>\n</robot>\n'})}),"\n",(0,s.jsx)(e.h2,{id:"6-validating-urdf-models",children:"6. Validating URDF Models"}),"\n",(0,s.jsx)(e.h3,{id:"61-using-check_urdf-tool",children:"6.1 Using check_urdf Tool"}),"\n",(0,s.jsxs)(e.p,{children:["The ",(0,s.jsx)(e.code,{children:"check_urdf"})," tool validates URDF syntax and structure:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Install the tool if not available\nsudo apt-get install ros-humble-urdfdom-tools\n\n# Validate your URDF file\ncheck_urdf /path/to/your/robot.urdf\n"})}),"\n",(0,s.jsx)(e.p,{children:"Expected output includes:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Parsing results"}),"\n",(0,s.jsx)(e.li,{children:"Number of links and joints"}),"\n",(0,s.jsx)(e.li,{children:"Joint types and limits"}),"\n",(0,s.jsx)(e.li,{children:"Kinematic tree structure"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"62-using-urdf_tutorial",children:"6.2 Using urdf_tutorial"}),"\n",(0,s.jsx)(e.p,{children:"Visualize your URDF model:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Launch the model visualizer\nroslaunch urdf_tutorial display.launch model:=/path/to/your/robot.urdf\n"})}),"\n",(0,s.jsx)(e.h3,{id:"63-common-validation-checks",children:"6.3 Common Validation Checks"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Mass Properties"}),": Ensure all links have positive mass values"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Inertia Values"}),": Verify inertia matrices are physically plausible"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Joint Limits"}),": Check that joint limits are reasonable for the robot"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Kinematic Chain"}),": Verify the model has a proper tree structure (no loops)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Collision Geometries"}),": Ensure collision geometries are properly defined"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"7-joint-constraints-and-physical-properties",children:"7. Joint Constraints and Physical Properties"}),"\n",(0,s.jsx)(e.h3,{id:"71-joint-limit-considerations",children:"7.1 Joint Limit Considerations"}),"\n",(0,s.jsx)(e.p,{children:"Proper joint limits are crucial for realistic robot behavior:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Realistic shoulder joint limits --\x3e\n<joint name="shoulder_pitch" type="revolute">\n  <limit lower="${-M_PI/2}" upper="${M_PI/2}" effort="50.0" velocity="2.0"/>\n</joint>\n\n\x3c!-- Elbow joint with physical constraints --\x3e\n<joint name="elbow_joint" type="revolute">\n  <limit lower="0" upper="${M_PI*0.9}" effort="30.0" velocity="2.5"/>\n</joint>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"72-inertial-parameter-estimation",children:"7.2 Inertial Parameter Estimation"}),"\n",(0,s.jsx)(e.p,{children:"Accurate inertial properties are essential for dynamic simulation:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Mass"}),": Use CAD models or estimate based on material density"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Center of Mass"}),": Should be at the geometric center for symmetric objects"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Inertia Tensor"}),": For a solid cylinder rotating about its central axis: Izz = \xbdmr\xb2"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"73-collision-vs-visual-geometry",children:"7.3 Collision vs Visual Geometry"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Visual Geometry"}),": Defines how the robot looks (can be complex)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Collision Geometry"}),": Defines physics interactions (should be simpler)"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<link name="complex_visual_link">\n  \x3c!-- Detailed visual mesh --\x3e\n  <visual>\n    <geometry>\n      <mesh filename="complex_shape.dae"/>\n    </geometry>\n  </visual>\n\n  \x3c!-- Simplified collision geometry --\x3e\n  <collision>\n    <geometry>\n      <cylinder radius="0.1" length="0.2"/>\n    </geometry>\n  </collision>\n</link>\n'})}),"\n",(0,s.jsx)(e.h2,{id:"8-sdf-extensions-for-simulation-specific-features",children:"8. SDF Extensions for Simulation-Specific Features"}),"\n",(0,s.jsx)(e.h3,{id:"81-adding-sensors-to-urdf-models",children:"8.1 Adding Sensors to URDF Models"}),"\n",(0,s.jsx)(e.p,{children:"While URDF doesn't natively support sensors, they can be added through Gazebo tags:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<link name="sensor_mount">\n  \x3c!-- Standard URDF elements --\x3e\n  <visual>\n    <geometry>\n      <box size="0.05 0.05 0.05"/>\n    </geometry>\n  </visual>\n  <collision>\n    <geometry>\n      <box size="0.05 0.05 0.05"/>\n    </geometry>\n  </collision>\n  <inertial>\n    <mass value="0.1"/>\n    <inertia ixx="0.001" ixy="0.0" ixz="0.0" iyy="0.001" iyz="0.0" izz="0.001"/>\n  </inertial>\n\n  \x3c!-- Gazebo-specific sensor definition --\x3e\n  <gazebo reference="sensor_mount">\n    <sensor name="imu_sensor" type="imu">\n      <always_on>true</always_on>\n      <update_rate>100</update_rate>\n      <imu>\n        <angular_velocity>\n          <x>\n            <noise type="gaussian">\n              <mean>0.0</mean>\n              <stddev>0.0017</stddev>\n            </noise>\n          </x>\n          <y>\n            <noise type="gaussian">\n              <mean>0.0</mean>\n              <stddev>0.0017</stddev>\n            </noise>\n          </y>\n          <z>\n            <noise type="gaussian">\n              <mean>0.0</mean>\n              <stddev>0.0017</stddev>\n            </noise>\n          </z>\n        </angular_velocity>\n        <linear_acceleration>\n          <x>\n            <noise type="gaussian">\n              <mean>0.0</mean>\n              <stddev>0.017</stddev>\n            </noise>\n          </x>\n          <y>\n            <noise type="gaussian">\n              <mean>0.0</mean>\n              <stddev>0.017</stddev>\n            </noise>\n          </y>\n          <z>\n            <noise type="gaussian">\n              <mean>0.0</mean>\n              <stddev>0.017</stddev>\n            </noise>\n          </z>\n        </linear_acceleration>\n      </imu>\n    </sensor>\n  </gazebo>\n</link>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"82-physics-properties-in-sdf",children:"8.2 Physics Properties in SDF"}),"\n",(0,s.jsx)(e.p,{children:"Advanced physics settings for more realistic simulation:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<link name="physical_link">\n  \x3c!-- Standard elements --\x3e\n  <collision name="collision">\n    <geometry>\n      <box size="0.1 0.1 0.1"/>\n    </geometry>\n    \x3c!-- Surface properties for realistic physics --\x3e\n    <surface>\n      <friction>\n        <ode>\n          <mu>0.5</mu>\n          <mu2>0.5</mu2>\n          <fdir1>0 0 0</fdir1>\n          <slip1>0</slip1>\n          <slip2>0</slip2>\n        </ode>\n      </friction>\n      <contact>\n        <ode>\n          <soft_cfm>0</soft_cfm>\n          <soft_erp>0.2</soft_erp>\n          <kp>1e+13</kp>\n          <kd>1.0</kd>\n          <max_vel>0.01</max_vel>\n          <min_depth>0</min_depth>\n        </ode>\n      </contact>\n      <bounce>\n        <restitution_coefficient>0.1</restitution_coefficient>\n        <threshold>100000</threshold>\n      </bounce>\n    </surface>\n  </collision>\n</link>\n'})}),"\n",(0,s.jsx)(e.h2,{id:"9-best-practices-for-humanoid-robot-modeling",children:"9. Best Practices for Humanoid Robot Modeling"}),"\n",(0,s.jsx)(e.h3,{id:"91-proportional-design",children:"9.1 Proportional Design"}),"\n",(0,s.jsx)(e.p,{children:"Humanoid robots should follow realistic proportions:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Leg length: ~40-45% of total height"}),"\n",(0,s.jsx)(e.li,{children:"Torso length: ~30-35% of total height"}),"\n",(0,s.jsx)(e.li,{children:"Arm length: ~35-40% of total height"}),"\n",(0,s.jsx)(e.li,{children:"Head size: ~8-10% of total height"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"92-center-of-mass-considerations",children:"9.2 Center of Mass Considerations"}),"\n",(0,s.jsx)(e.p,{children:"For stable bipedal locomotion:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Keep overall center of mass low"}),"\n",(0,s.jsx)(e.li,{children:"Distribute mass appropriately in limbs"}),"\n",(0,s.jsx)(e.li,{children:"Consider the effect of actuator placement"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"93-joint-configuration-for-locomotion",children:"9.3 Joint Configuration for Locomotion"}),"\n",(0,s.jsx)(e.p,{children:"Key joints for humanoid locomotion:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"6DOF at feet for balance control"}),"\n",(0,s.jsx)(e.li,{children:"Hip joints with pitch, roll, and yaw"}),"\n",(0,s.jsx)(e.li,{children:"Knee joints with appropriate flexion limits"}),"\n",(0,s.jsx)(e.li,{children:"Ankle joints for fine balance adjustments"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"10-summary",children:"10. Summary"}),"\n",(0,s.jsx)(e.p,{children:"This chapter covered the fundamentals of robot description formats, focusing on:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"URDF for robot structure definition with links, joints, and properties"}),"\n",(0,s.jsx)(e.li,{children:"SDF for simulation-specific enhancements and features"}),"\n",(0,s.jsx)(e.li,{children:"Differences between the two formats and appropriate use cases"}),"\n",(0,s.jsx)(e.li,{children:"Xacro macros for managing complex robot descriptions"}),"\n",(0,s.jsx)(e.li,{children:"Proper validation techniques for URDF models"}),"\n",(0,s.jsx)(e.li,{children:"Joint constraints and physical properties for realistic simulation"}),"\n",(0,s.jsx)(e.li,{children:"SDF extensions for sensors and advanced physics"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"With accurate robot models, you can now proceed to configure realistic physics simulations and sensor systems, which will be covered in the next chapter."}),"\n",(0,s.jsx)(e.h2,{id:"11-exercises-and-practice",children:"11. Exercises and Practice"}),"\n",(0,s.jsx)(e.p,{children:"Complete the following exercises to reinforce your understanding of URDF and SDF robot description formats:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"/Physicial_Ai_Book_Hackathon_1/docs/module-3-digital-twin/chapter-2-robot-modeling/exercises",children:"Chapter 2 Exercises"})," - Practice problems covering URDF modeling, Xacro macros, and SDF extensions"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"/Physicial_Ai_Book_Hackathon_1/docs/module-3-digital-twin/chapter-2-robot-modeling/solutions",children:"Chapter 2 Solutions"})," - Complete implementations and solution guides"]}),"\n"]})]})}function m(n={}){const{wrapper:e}={...(0,l.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(c,{...n})}):c(n)}},8453(n,e,i){i.d(e,{R:()=>o,x:()=>t});var r=i(6540);const s={},l=r.createContext(s);function o(n){const e=r.useContext(l);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function t(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:o(n.components),r.createElement(l.Provider,{value:e},n.children)}}}]);