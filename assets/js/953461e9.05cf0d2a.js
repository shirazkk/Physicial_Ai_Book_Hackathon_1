"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[8665],{4566(e,n,s){s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"module-2-robotic-nervous-system/chapter-1/ros2-architecture","title":"Understanding ROS 2 Architecture and Communication Patterns","description":"Learning Objectives","source":"@site/docs/module-2-robotic-nervous-system/chapter-1/ros2-architecture.md","sourceDirName":"module-2-robotic-nervous-system/chapter-1","slug":"/module-2-robotic-nervous-system/chapter-1/ros2-architecture","permalink":"/Physicial_Ai_Book_Hackathon_1/docs/module-2-robotic-nervous-system/chapter-1/ros2-architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/shirazkk/Physicial_Ai_Book_Hackathon_1/edit/main/my-website/docs/module-2-robotic-nervous-system/chapter-1/ros2-architecture.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Module 1: Cross-References and Connections","permalink":"/Physicial_Ai_Book_Hackathon_1/docs/module-1-foundation/cross-references"},"next":{"title":"Exercises: ROS 2 Architecture and Communication Patterns","permalink":"/Physicial_Ai_Book_Hackathon_1/docs/module-2-robotic-nervous-system/chapter-1/exercises"}}');var r=s(4848),t=s(8453);const o={},l="Understanding ROS 2 Architecture and Communication Patterns",a={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Introduction",id:"introduction",level:2},{value:"1. ROS 2 Architecture Fundamentals",id:"1-ros-2-architecture-fundamentals",level:2},{value:"1.1 Nodes",id:"11-nodes",level:3},{value:"1.2 Topics and Publishing/Subscription",id:"12-topics-and-publishingsubscription",level:3},{value:"1.3 Services",id:"13-services",level:3},{value:"1.4 Actions",id:"14-actions",level:3},{value:"2. Quality of Service (QoS) Settings",id:"2-quality-of-service-qos-settings",level:2},{value:"3. Namespaces and Parameter Management",id:"3-namespaces-and-parameter-management",level:2},{value:"4. Practical Example: Simple Robot Controller",id:"4-practical-example-simple-robot-controller",level:2},{value:"5. Exercise: Create a Basic ROS 2 Publisher-Subscriber System",id:"5-exercise-create-a-basic-ros-2-publisher-subscriber-system",level:2},{value:"Objective",id:"objective",level:3},{value:"Instructions",id:"instructions",level:3},{value:"Expected Outcome",id:"expected-outcome",level:3},{value:"6. Summary",id:"6-summary",level:2},{value:"7. Exercises and Practice",id:"7-exercises-and-practice",level:2},{value:"8. Further Reading",id:"8-further-reading",level:2},{value:"9. Links to External Resources",id:"9-links-to-external-resources",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"understanding-ros-2-architecture-and-communication-patterns",children:"Understanding ROS 2 Architecture and Communication Patterns"})}),"\n",(0,r.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsx)(n.p,{children:"By the end of this chapter, readers will be able to:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Explain the fundamental architecture of ROS 2 and its core components"}),"\n",(0,r.jsx)(n.li,{children:"Create and run basic ROS 2 nodes using Python and rclpy"}),"\n",(0,r.jsx)(n.li,{children:"Implement publisher-subscriber communication patterns"}),"\n",(0,r.jsx)(n.li,{children:"Use service client-server communication for request-response interactions"}),"\n",(0,r.jsx)(n.li,{children:"Apply action client-server patterns for long-running operations with feedback"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Basic Python programming knowledge"}),"\n",(0,r.jsx)(n.li,{children:"Completion of Module 1: Foundations of Physical AI & Humanoid Robotics"}),"\n",(0,r.jsx)(n.li,{children:"Understanding of distributed systems concepts (helpful but not required)"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsx)(n.p,{children:"The Robot Operating System 2 (ROS 2) provides the middleware infrastructure that enables communication between different components of robotic systems. Understanding ROS 2 architecture is fundamental to working with any ROS 2-based robotic system. This chapter covers the core concepts of ROS 2 architecture, including nodes, topics, services, and actions, which form the backbone of distributed robotic systems."}),"\n",(0,r.jsx)(n.p,{children:"ROS 2 represents a significant evolution from ROS 1, addressing critical requirements for production systems including real-time performance, security, and support for multiple operating systems. The architecture is built on DDS (Data Distribution Service) which provides a robust communication infrastructure for distributed systems."}),"\n",(0,r.jsx)(n.h2,{id:"1-ros-2-architecture-fundamentals",children:"1. ROS 2 Architecture Fundamentals"}),"\n",(0,r.jsx)(n.h3,{id:"11-nodes",children:"1.1 Nodes"}),"\n",(0,r.jsx)(n.p,{children:"A node is an independent process that performs computation. Nodes are the fundamental building blocks of ROS 2 programs. Each node can perform specific functions such as sensor data processing, control algorithm execution, or user interface management."}),"\n",(0,r.jsx)(n.p,{children:"Key characteristics of nodes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Each node runs in its own process"}),"\n",(0,r.jsx)(n.li,{children:"Nodes communicate with other nodes using topics, services, and actions"}),"\n",(0,r.jsx)(n.li,{children:"Nodes can be organized hierarchically using namespaces"}),"\n",(0,r.jsx)(n.li,{children:"Nodes must be uniquely named within a ROS domain"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Example: Creating a basic ROS 2 node\nimport rclpy\nfrom rclpy.node import Node\n\nclass MinimalNode(Node):\n\n    def __init__(self):\n        super().__init__('minimal_publisher')\n        # Node initialization code goes here\n        self.get_logger().info('Minimal node created')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_node = MinimalNode()\n\n    try:\n        rclpy.spin(minimal_node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        minimal_node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"12-topics-and-publishingsubscription",children:"1.2 Topics and Publishing/Subscription"}),"\n",(0,r.jsx)(n.p,{children:"Topics enable asynchronous communication between nodes through a publish/subscribe pattern. Publishers send messages to topics, and subscribers receive messages from topics. This pattern supports one-to-many communication."}),"\n",(0,r.jsx)(n.p,{children:"Key characteristics of topics:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Asynchronous communication"}),"\n",(0,r.jsx)(n.li,{children:"One publisher can have many subscribers"}),"\n",(0,r.jsx)(n.li,{children:"Many publishers can send to the same topic"}),"\n",(0,r.jsx)(n.li,{children:"Message types must be consistent across publisher/subscriber pairs"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Publisher example\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass MinimalPublisher(Node):\n\n    def __init__(self):\n        super().__init__('minimal_publisher')\n        self.publisher = self.create_publisher(String, 'topic', 10)\n        timer_period = 0.5  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n        self.i = 0\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = f'Hello World: {self.i}'\n        self.publisher.publish(msg)\n        self.get_logger().info(f'Publishing: \"{msg.data}\"')\n        self.i += 1\n\n# Subscriber example\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass MinimalSubscriber(Node):\n\n    def __init__(self):\n        super().__init__('minimal_subscriber')\n        self.subscription = self.create_subscription(\n            String,\n            'topic',\n            self.listener_callback,\n            10)\n        self.subscription  # prevent unused variable warning\n\n    def listener_callback(self, msg):\n        self.get_logger().info(f'I heard: \"{msg.data}\"')\n"})}),"\n",(0,r.jsx)(n.h3,{id:"13-services",children:"1.3 Services"}),"\n",(0,r.jsx)(n.p,{children:"Services provide synchronous request/response communication between nodes. A service client sends a request to a service server, which processes the request and returns a response."}),"\n",(0,r.jsx)(n.p,{children:"Key characteristics of services:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Synchronous communication"}),"\n",(0,r.jsx)(n.li,{children:"Request/response pattern"}),"\n",(0,r.jsx)(n.li,{children:"One-to-one communication between client and server"}),"\n",(0,r.jsx)(n.li,{children:"Useful for operations that have a clear start and end"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Service server example\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import AddTwoInts\n\nclass MinimalService(Node):\n\n    def __init__(self):\n        super().__init__('minimal_service')\n        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)\n\n    def add_two_ints_callback(self, request, response):\n        response.sum = request.a + request.b\n        self.get_logger().info(f'Returning {request.a} + {request.b} = {response.sum}')\n        return response\n\n# Service client example\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import AddTwoInts\n\nclass MinimalClientAsync(Node):\n\n    def __init__(self):\n        super().__init__('minimal_client_async')\n        self.cli = self.create_client(AddTwoInts, 'add_two_ints')\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Service not available, waiting again...')\n        self.req = AddTwoInts.Request()\n\n    def send_request(self, a, b):\n        self.req.a = a\n        self.req.b = b\n        self.future = self.cli.call_async(self.req)\n        rclpy.spin_until_future_complete(self, self.future)\n        return self.future.result()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"14-actions",children:"1.4 Actions"}),"\n",(0,r.jsx)(n.p,{children:"Actions provide asynchronous request/response communication with feedback for long-running operations. They include three parts: goal, feedback, and result."}),"\n",(0,r.jsx)(n.p,{children:"Key characteristics of actions:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Asynchronous communication"}),"\n",(0,r.jsx)(n.li,{children:"Goal, feedback, and result phases"}),"\n",(0,r.jsx)(n.li,{children:"Support for cancellation and preemption"}),"\n",(0,r.jsx)(n.li,{children:"Ideal for long-running operations with progress updates"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Action server example\nimport rclpy\nfrom rclpy.action import ActionServer\nfrom rclpy.node import Node\nfrom example_interfaces.action import Fibonacci\n\nclass FibonacciActionServer(Node):\n\n    def __init__(self):\n        super().__init__('fibonacci_action_server')\n        self._action_server = ActionServer(\n            self,\n            Fibonacci,\n            'fibonacci',\n            self.execute_callback)\n\n    def execute_callback(self, goal_handle):\n        self.get_logger().info('Executing goal...')\n\n        feedback_msg = Fibonacci.Feedback()\n        feedback_msg.sequence = [0, 1]\n\n        for i in range(1, goal_handle.request.order):\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                self.get_logger().info('Goal canceled')\n                return Fibonacci.Result()\n\n            feedback_msg.sequence.append(\n                feedback_msg.sequence[i] + feedback_msg.sequence[i-1])\n\n            self.get_logger().info(f'Feedback: {feedback_msg.sequence}')\n            goal_handle.publish_feedback(feedback_msg)\n\n        goal_handle.succeed()\n        result = Fibonacci.Result()\n        result.sequence = feedback_msg.sequence\n        self.get_logger().info(f'Returning result: {result.sequence}')\n\n        return result\n\n# Action client example\nimport rclpy\nfrom rclpy.action import ActionClient\nfrom rclpy.node import Node\nfrom example_interfaces.action import Fibonacci\n\nclass FibonacciActionClient(Node):\n\n    def __init__(self):\n        super().__init__('fibonacci_action_client')\n        self._action_client = ActionClient(\n            self,\n            Fibonacci,\n            'fibonacci')\n\n    def send_goal(self, order):\n        goal_msg = Fibonacci.Goal()\n        goal_msg.order = order\n\n        self._action_client.wait_for_server()\n        self._send_goal_future = self._action_client.send_goal_async(\n            goal_msg,\n            feedback_callback=self.feedback_callback)\n\n        self._send_goal_future.add_done_callback(self.goal_response_callback)\n\n    def goal_response_callback(self, future):\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info('Goal rejected')\n            return\n\n        self.get_logger().info('Goal accepted')\n        self._get_result_future = goal_handle.get_result_async()\n        self._get_result_future.add_done_callback(self.get_result_callback)\n\n    def feedback_callback(self, feedback_msg):\n        feedback = feedback_msg.feedback\n        self.get_logger().info(f'Received feedback: {feedback.sequence}')\n"})}),"\n",(0,r.jsx)(n.h2,{id:"2-quality-of-service-qos-settings",children:"2. Quality of Service (QoS) Settings"}),"\n",(0,r.jsx)(n.p,{children:"QoS settings allow fine-tuning of communication behavior between nodes. They control reliability, durability, liveliness, and other aspects of message delivery."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from rclpy.qos import QoSProfile, QoSDurabilityPolicy, QoSHistoryPolicy, QoSReliabilityPolicy\n\n# Example: Configuring QoS for a publisher\nqos_profile = QoSProfile(\n    depth=10,\n    durability=QoSDurabilityPolicy.TRANSIENT_LOCAL,\n    reliability=QoSReliabilityPolicy.RELIABLE,\n    history=QoSHistoryPolicy.KEEP_LAST)\n\npublisher = self.create_publisher(String, 'topic', qos_profile)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"3-namespaces-and-parameter-management",children:"3. Namespaces and Parameter Management"}),"\n",(0,r.jsx)(n.p,{children:"Namespaces provide a way to organize nodes hierarchically, while parameters allow runtime configuration."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class ParameterNode(Node):\n\n    def __init__(self):\n        super().__init__('parameter_node')\n\n        # Declare parameters\n        self.declare_parameter('param_name', 'default_value')\n\n        # Get parameter value\n        param_value = self.get_parameter('param_name').value\n\n        # Callback for parameter changes\n        self.add_on_set_parameters_callback(self.parameter_callback)\n\n    def parameter_callback(self, params):\n        for param in params:\n            if param.name == 'param_name':\n                self.get_logger().info(f'Parameter {param.name} changed to {param.value}')\n        return SetParametersResult(successful=True)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"4-practical-example-simple-robot-controller",children:"4. Practical Example: Simple Robot Controller"}),"\n",(0,r.jsx)(n.p,{children:"Let's create a complete example that demonstrates multiple ROS 2 concepts:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String, Float64\nfrom geometry_msgs.msg import Twist\nfrom example_interfaces.srv import SetBool\n\nclass SimpleRobotController(Node):\n\n    def __init__(self):\n        super().__init__('simple_robot_controller')\n\n        # Publishers\n        self.cmd_vel_pub = self.create_publisher(Twist, '/cmd_vel', 10)\n        self.status_pub = self.create_publisher(String, '/robot_status', 10)\n\n        # Subscribers\n        self.sensor_sub = self.create_subscription(\n            Float64, '/sensor_data', self.sensor_callback, 10)\n\n        # Services\n        self.emergency_stop_srv = self.create_service(\n            SetBool, '/emergency_stop', self.emergency_stop_callback)\n\n        # Timers\n        self.control_timer = self.create_timer(0.1, self.control_loop)\n\n        # Internal state\n        self.robot_enabled = True\n        self.sensor_value = 0.0\n\n        self.get_logger().info('Simple Robot Controller initialized')\n\n    def sensor_callback(self, msg):\n        self.sensor_value = msg.data\n\n    def emergency_stop_callback(self, request, response):\n        if request.data:\n            self.robot_enabled = False\n            self.get_logger().warn('EMERGENCY STOP ACTIVATED')\n        else:\n            self.robot_enabled = True\n            self.get_logger().info('Robot re-enabled')\n\n        response.success = True\n        response.message = f'Robot enabled status: {self.robot_enabled}'\n        return response\n\n    def control_loop(self):\n        if not self.robot_enabled:\n            # Send stop command\n            cmd = Twist()\n            cmd.linear.x = 0.0\n            cmd.angular.z = 0.0\n            self.cmd_vel_pub.publish(cmd)\n            return\n\n        # Simple control logic based on sensor value\n        cmd = Twist()\n        cmd.linear.x = min(1.0, max(-1.0, self.sensor_value * 0.1))\n        cmd.angular.z = min(1.0, max(-1.0, self.sensor_value * 0.05))\n\n        self.cmd_vel_pub.publish(cmd)\n\n        # Publish status\n        status_msg = String()\n        status_msg.data = f'Sensor: {self.sensor_value:.2f}, Enabled: {self.robot_enabled}'\n        self.status_pub.publish(status_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    controller = SimpleRobotController()\n\n    try:\n        rclpy.spin(controller)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        controller.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.h2,{id:"5-exercise-create-a-basic-ros-2-publisher-subscriber-system",children:"5. Exercise: Create a Basic ROS 2 Publisher-Subscriber System"}),"\n",(0,r.jsx)(n.h3,{id:"objective",children:"Objective"}),"\n",(0,r.jsx)(n.p,{children:"Create a simple publisher-subscriber system that demonstrates the basic communication pattern in ROS 2."}),"\n",(0,r.jsx)(n.h3,{id:"instructions",children:"Instructions"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Create a publisher node that publishes a counter value every second"}),"\n",(0,r.jsx)(n.li,{children:"Create a subscriber node that receives and logs the counter value"}),"\n",(0,r.jsx)(n.li,{children:"Run both nodes and observe the communication"}),"\n",(0,r.jsx)(n.li,{children:"Experiment with different QoS settings to see their effect"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"expected-outcome",children:"Expected Outcome"}),"\n",(0,r.jsx)(n.p,{children:"Two nodes communicating via a topic, with the subscriber successfully receiving messages from the publisher."}),"\n",(0,r.jsx)(n.h2,{id:"6-summary",children:"6. Summary"}),"\n",(0,r.jsx)(n.p,{children:"This chapter introduced the fundamental architecture of ROS 2, including:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Nodes as the basic computational units"}),"\n",(0,r.jsx)(n.li,{children:"Topics for asynchronous publish/subscribe communication"}),"\n",(0,r.jsx)(n.li,{children:"Services for synchronous request/response communication"}),"\n",(0,r.jsx)(n.li,{children:"Actions for long-running operations with feedback"}),"\n",(0,r.jsx)(n.li,{children:"QoS settings for fine-tuning communication behavior"}),"\n",(0,r.jsx)(n.li,{children:"Namespaces and parameters for organization and configuration"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Understanding these concepts is essential for building distributed robotic systems with ROS 2. The next chapter will build upon these foundations to show how to bridge AI agents to robot controllers."}),"\n",(0,r.jsx)(n.h2,{id:"7-exercises-and-practice",children:"7. Exercises and Practice"}),"\n",(0,r.jsx)(n.p,{children:"Complete the following exercises to reinforce your understanding of ROS 2 architecture:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/Physicial_Ai_Book_Hackathon_1/docs/module-2-robotic-nervous-system/chapter-1/exercises",children:"Chapter 1 Exercises"})," - Practice problems covering ROS 2 communication patterns"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/Physicial_Ai_Book_Hackathon_1/docs/module-2-robotic-nervous-system/chapter-1/solutions",children:"Chapter 1 Solutions"})," - Complete implementations and solution guides"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"8-further-reading",children:"8. Further Reading"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://docs.ros.org/en/humble/",children:"ROS 2 Documentation"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://index.ros.org/doc/ros2/About-Ros2-design/",children:"ROS 2 Design Papers"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Concepts/About-Quality-of-Service-settings/",children:"Quality of Service in ROS 2"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"9-links-to-external-resources",children:"9. Links to External Resources"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://docs.ros.org/en/humble/",children:"ROS 2 Humble Hawksbill Documentation"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Tutorials.html",children:"ROS 2 Tutorials"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://design.ros2.org/",children:"ROS 2 Design Principles"})}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453(e,n,s){s.d(n,{R:()=>o,x:()=>l});var i=s(6540);const r={},t=i.createContext(r);function o(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);