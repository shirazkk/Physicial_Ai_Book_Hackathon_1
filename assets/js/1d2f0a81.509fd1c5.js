"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[6264],{1715(n,e,t){t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"module-1-foundation/chapter2-kinematics-dynamics","title":"Chapter 2: Kinematics and Dynamics for Physical AI & Robotics","description":"Learning Objectives","source":"@site/docs/module-1-foundation/chapter2-kinematics-dynamics.md","sourceDirName":"module-1-foundation","slug":"/module-1-foundation/chapter2-kinematics-dynamics","permalink":"/Physicial_Ai_Book_Hackathon_1/docs/module-1-foundation/chapter2-kinematics-dynamics","draft":false,"unlisted":false,"editUrl":"https://github.com/shirazkk/Physicial_Ai_Book_Hackathon_1/edit/main/my-website/docs/module-1-foundation/chapter2-kinematics-dynamics.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 1: Mathematical Foundations for Physical AI & Robotics","permalink":"/Physicial_Ai_Book_Hackathon_1/docs/module-1-foundation/chapter1-mathematical-foundations"},"next":{"title":"Chapter 3: Sensing and Perception for Physical AI & Robotics","permalink":"/Physicial_Ai_Book_Hackathon_1/docs/module-1-foundation/chapter3-sensing-perception"}}');var a=t(4848),o=t(8453);const r={},s="Chapter 2: Kinematics and Dynamics for Physical AI & Robotics",l={},d=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Introduction",id:"introduction",level:2},{value:"1. Forward Kinematics",id:"1-forward-kinematics",level:2},{value:"1.1 Denavit-Hartenberg (DH) Convention",id:"11-denavit-hartenberg-dh-convention",level:3},{value:"1.2 Homogeneous Transformation Matrices",id:"12-homogeneous-transformation-matrices",level:3},{value:"2. Inverse Kinematics",id:"2-inverse-kinematics",level:2},{value:"2.1 Analytical Solutions",id:"21-analytical-solutions",level:3},{value:"2.2 Numerical Solutions",id:"22-numerical-solutions",level:3},{value:"3. Robot Dynamics",id:"3-robot-dynamics",level:2},{value:"3.1 Newton-Euler Formulation",id:"31-newton-euler-formulation",level:3},{value:"3.2 Lagrangian Formulation",id:"32-lagrangian-formulation",level:3},{value:"3.3 Dynamic Model for Multi-DOF Manipulator",id:"33-dynamic-model-for-multi-dof-manipulator",level:3},{value:"4. Control Theory Fundamentals",id:"4-control-theory-fundamentals",level:2},{value:"4.1 PID Control",id:"41-pid-control",level:3},{value:"5. PyBullet Examples for Kinematics and Dynamics",id:"5-pybullet-examples-for-kinematics-and-dynamics",level:2},{value:"6. Kinematics and Dynamics Exercises",id:"6-kinematics-and-dynamics-exercises",level:2},{value:"Exercise 1: Forward Kinematics Implementation",id:"exercise-1-forward-kinematics-implementation",level:3},{value:"Exercise 2: Simple Dynamic Simulation",id:"exercise-2-simple-dynamic-simulation",level:3},{value:"7. Summary",id:"7-summary",level:2},{value:"8. Implementation Guide",id:"8-implementation-guide",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"chapter-2-kinematics-and-dynamics-for-physical-ai--robotics",children:"Chapter 2: Kinematics and Dynamics for Physical AI & Robotics"})}),"\n",(0,a.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,a.jsx)(e.p,{children:"By the end of this chapter, readers will be able to:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Calculate forward kinematics for robotic manipulators using transformation matrices"}),"\n",(0,a.jsx)(e.li,{children:"Solve inverse kinematics problems for simple robotic systems"}),"\n",(0,a.jsx)(e.li,{children:"Model and analyze dynamic behavior of robotic systems"}),"\n",(0,a.jsx)(e.li,{children:"Apply Newton-Euler and Lagrangian methods for dynamic analysis"}),"\n",(0,a.jsx)(e.li,{children:"Implement kinematic and dynamic models using PyBullet simulation"}),"\n",(0,a.jsx)(e.li,{children:"Predict and control robot motion based on kinematic and dynamic principles"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Understanding of linear algebra concepts (covered in Chapter 1)"}),"\n",(0,a.jsx)(e.li,{children:"Basic calculus knowledge (covered in Chapter 1)"}),"\n",(0,a.jsx)(e.li,{children:"Fundamental physics concepts (forces, torques, motion)"}),"\n",(0,a.jsx)(e.li,{children:"Basic Python programming skills"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(e.p,{children:"Kinematics and dynamics form the core of robot motion understanding and control. Kinematics deals with the geometry of motion without considering forces, while dynamics analyzes motion considering the forces and torques that cause it. This chapter covers both forward and inverse kinematics, as well as dynamic modeling and analysis of robotic systems."}),"\n",(0,a.jsx)(e.h2,{id:"1-forward-kinematics",children:"1. Forward Kinematics"}),"\n",(0,a.jsx)(e.p,{children:"Forward kinematics determines the position and orientation of the end-effector given the joint angles of a robotic manipulator."}),"\n",(0,a.jsx)(e.h3,{id:"11-denavit-hartenberg-dh-convention",children:"1.1 Denavit-Hartenberg (DH) Convention"}),"\n",(0,a.jsx)(e.p,{children:"The DH convention is a systematic method for assigning coordinate frames to robotic links."}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"DH Parameters"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"a\u1d62: link length (distance along x\u1d62 from z\u1d62 to z\u1d62\u208a\u2081)"}),"\n",(0,a.jsx)(e.li,{children:"\u03b1\u1d62: link twist (angle from z\u1d62 to z\u1d62\u208a\u2081 about x\u1d62)"}),"\n",(0,a.jsx)(e.li,{children:"d\u1d62: link offset (distance along z\u1d62 from x\u1d62\u208b\u2081 to x\u1d62)"}),"\n",(0,a.jsx)(e.li,{children:"\u03b8\u1d62: joint angle (angle from x\u1d62\u208b\u2081 to x\u1d62 about z\u1d62)"}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import numpy as np\n\ndef dh_transform(a, alpha, d, theta):\n    """\n    Denavit-Hartenberg transformation matrix\n    a: link length\n    alpha: link twist\n    d: link offset\n    theta: joint angle\n    """\n    T = np.array([\n        [np.cos(theta), -np.sin(theta)*np.cos(alpha), np.sin(theta)*np.sin(alpha), a*np.cos(theta)],\n        [np.sin(theta), np.cos(theta)*np.cos(alpha), -np.cos(theta)*np.sin(alpha), a*np.sin(theta)],\n        [0, np.sin(alpha), np.cos(alpha), d],\n        [0, 0, 0, 1]\n    ])\n    return T\n\n# Example: 2-DOF planar manipulator\ndef forward_kinematics_2dof(theta1, theta2, l1, l2):\n    """\n    Forward kinematics for 2-DOF planar manipulator\n    theta1, theta2: joint angles\n    l1, l2: link lengths\n    Returns: end-effector position [x, y]\n    """\n    # Calculate transformation matrices\n    T1 = dh_transform(l1, 0, 0, theta1)\n    T2 = dh_transform(l2, 0, 0, theta2)\n\n    # Total transformation from base to end-effector\n    T_total = T1 @ T2\n\n    # Extract end-effector position\n    x = T_total[0, 3]\n    y = T_total[1, 3]\n    z = T_total[2, 3]\n\n    return np.array([x, y, z])\n\n# Example calculation\ntheta1 = np.pi/4  # 45 degrees\ntheta2 = np.pi/6  # 30 degrees\nl1 = 1.0\nl2 = 0.8\n\nend_effector_pos = forward_kinematics_2dof(theta1, theta2, l1, l2)\nprint(f"End-effector position: {end_effector_pos}")\n'})}),"\n",(0,a.jsx)(e.h3,{id:"12-homogeneous-transformation-matrices",children:"1.2 Homogeneous Transformation Matrices"}),"\n",(0,a.jsx)(e.p,{children:"Using homogeneous transformation matrices to represent position and orientation."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'def rotation_matrix_x(angle):\n    """Rotation matrix around X-axis"""\n    return np.array([\n        [1, 0, 0],\n        [0, np.cos(angle), -np.sin(angle)],\n        [0, np.sin(angle), np.cos(angle)]\n    ])\n\ndef rotation_matrix_y(angle):\n    """Rotation matrix around Y-axis"""\n    return np.array([\n        [np.cos(angle), 0, np.sin(angle)],\n        [0, 1, 0],\n        [-np.sin(angle), 0, np.cos(angle)]\n    ])\n\ndef rotation_matrix_z(angle):\n    """Rotation matrix around Z-axis"""\n    return np.array([\n        [np.cos(angle), -np.sin(angle), 0],\n        [np.sin(angle), np.cos(angle), 0],\n        [0, 0, 1]\n    ])\n\ndef homogeneous_transform(rotation_matrix, translation_vector):\n    """Create a 4x4 homogeneous transformation matrix"""\n    T = np.eye(4)\n    T[0:3, 0:3] = rotation_matrix\n    T[0:3, 3] = translation_vector\n    return T\n\n# Example: Create transformation for a simple case\nangle = np.pi / 3  # 60 degrees\nR = rotation_matrix_z(angle)\nt = np.array([2.0, 1.0, 0.5])\nT = homogeneous_transform(R, t)\nprint(f"Homogeneous transformation matrix:\\n{T}")\n'})}),"\n",(0,a.jsx)(e.h2,{id:"2-inverse-kinematics",children:"2. Inverse Kinematics"}),"\n",(0,a.jsx)(e.p,{children:"Inverse kinematics determines the joint angles required to achieve a desired end-effector position and orientation."}),"\n",(0,a.jsx)(e.h3,{id:"21-analytical-solutions",children:"2.1 Analytical Solutions"}),"\n",(0,a.jsx)(e.p,{children:"For simple manipulators, analytical solutions may be possible."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'def inverse_kinematics_2dof(x, y, l1, l2):\n    """\n    Inverse kinematics for 2-DOF planar manipulator\n    x, y: desired end-effector position\n    l1, l2: link lengths\n    Returns: joint angles [theta1, theta2] or None if no solution\n    """\n    # Check if position is reachable\n    r = np.sqrt(x**2 + y**2)\n    if r > l1 + l2:\n        print("Position is outside workspace")\n        return None\n\n    if r < abs(l1 - l2):\n        print("Position is inside workspace but unreachable")\n        return None\n\n    # Calculate theta2\n    cos_theta2 = (x**2 + y**2 - l1**2 - l2**2) / (2 * l1 * l2)\n    sin_theta2 = np.sqrt(1 - cos_theta2**2)\n    theta2 = np.arctan2(sin_theta2, cos_theta2)\n\n    # Calculate theta1\n    k1 = l1 + l2 * cos_theta2\n    k2 = l2 * sin_theta2\n    theta1 = np.arctan2(y, x) - np.arctan2(k2, k1)\n\n    return np.array([theta1, theta2])\n\n# Example: Find joint angles for desired position\ndesired_pos = np.array([1.2, 0.8])\nangles = inverse_kinematics_2dof(desired_pos[0], desired_pos[1], l1, l2)\nif angles is not None:\n    print(f"Required joint angles: {np.degrees(angles)} degrees")\n\n    # Verify with forward kinematics\n    verify_pos = forward_kinematics_2dof(angles[0], angles[1], l1, l2)\n    print(f"Verification - Forward kinematics result: {verify_pos[:2]}")\n    print(f"Desired position: {desired_pos}")\n'})}),"\n",(0,a.jsx)(e.h3,{id:"22-numerical-solutions",children:"2.2 Numerical Solutions"}),"\n",(0,a.jsx)(e.p,{children:"For complex manipulators, numerical methods are often necessary."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'def jacobian_2dof(theta1, theta2, l1, l2):\n    """\n    Jacobian matrix for 2-DOF planar manipulator\n    The Jacobian relates joint velocities to end-effector velocities\n    """\n    J = np.array([\n        [-l1*np.sin(theta1) - l2*np.sin(theta1 + theta2), -l2*np.sin(theta1 + theta2)],\n        [l1*np.cos(theta1) + l2*np.cos(theta1 + theta2), l2*np.cos(theta1 + theta2)]\n    ])\n    return J\n\ndef numerical_inverse_kinematics(desired_pos, initial_angles, l1, l2, max_iterations=100, tolerance=1e-6):\n    """\n    Numerical inverse kinematics using Jacobian transpose method\n    """\n    angles = initial_angles.copy()\n\n    for i in range(max_iterations):\n        # Calculate current position\n        current_pos = forward_kinematics_2dof(angles[0], angles[1], l1, l2)[:2]\n\n        # Calculate error\n        error = desired_pos - current_pos\n\n        # Check if we\'re close enough\n        if np.linalg.norm(error) < tolerance:\n            print(f"Converged after {i+1} iterations")\n            return angles\n\n        # Calculate Jacobian\n        J = jacobian_2dof(angles[0], angles[1], l1, l2)\n\n        # Update angles using Jacobian transpose\n        angles += 0.01 * J.T @ error  # Small step size for stability\n\n    print(f"Did not converge after {max_iterations} iterations")\n    return angles\n\n# Example: Numerical inverse kinematics\ninitial_guess = np.array([0.5, 0.5])  # Initial guess for joint angles\nnumerical_angles = numerical_inverse_kinematics(desired_pos, initial_guess, l1, l2)\nprint(f"Numerical solution - Joint angles: {np.degrees(numerical_angles)} degrees")\n'})}),"\n",(0,a.jsx)(e.h2,{id:"3-robot-dynamics",children:"3. Robot Dynamics"}),"\n",(0,a.jsx)(e.p,{children:"Robot dynamics deals with the forces and torques that cause motion in robotic systems."}),"\n",(0,a.jsx)(e.h3,{id:"31-newton-euler-formulation",children:"3.1 Newton-Euler Formulation"}),"\n",(0,a.jsx)(e.p,{children:"The Newton-Euler method applies Newton's laws to each link of the manipulator."}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Newton's equation"}),": F = ma (for translational motion)\n",(0,a.jsx)(e.strong,{children:"Euler's equation"}),": \u03c4 = I\u03b1 (for rotational motion)"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'def newton_euler_1dof(theta, theta_dot, theta_ddot, mass, length, gravity=9.81):\n    """\n    Simple dynamics for 1-DOF pendulum using Newton-Euler formulation\n    """\n    # For a simple pendulum: \u03c4 = I*\u03b8_ddot + m*g*l*sin(\u03b8)\n    # Moment of inertia for point mass at end of rod: I = m*l\xb2\n    inertia = mass * length**2\n\n    # External torque needed to achieve desired acceleration\n    required_torque = inertia * theta_ddot + mass * gravity * length * np.sin(theta)\n\n    return required_torque\n\n# Example: Calculate torque for 1-DOF pendulum\nmass = 1.0  # kg\nlength = 1.0  # m\ntheta = np.pi/6  # 30 degrees\ntheta_dot = 0.5  # rad/s\ntheta_ddot = 0.2  # rad/s\xb2\n\ntorque = newton_euler_1dof(theta, theta_dot, theta_ddot, mass, length)\nprint(f"Required torque: {torque:.3f} N\xb7m")\n'})}),"\n",(0,a.jsx)(e.h3,{id:"32-lagrangian-formulation",children:"3.2 Lagrangian Formulation"}),"\n",(0,a.jsx)(e.p,{children:"The Lagrangian method uses energy principles to derive equations of motion."}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Lagrangian"}),": L = T - V (Kinetic Energy - Potential Energy)\n",(0,a.jsx)(e.strong,{children:"Euler-Lagrange Equation"}),": d/dt(\u2202L/\u2202q\u0307) - \u2202L/\u2202q = \u03c4"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'def lagrangian_1dof_pendulum(theta, theta_dot, mass, length, gravity=9.81):\n    """\n    Calculate Lagrangian for 1-DOF pendulum\n    """\n    # Kinetic energy: T = 1/2 * I * \u03b8_dot\xb2\n    # For pendulum: I = m*l\xb2\n    kinetic_energy = 0.5 * mass * length**2 * theta_dot**2\n\n    # Potential energy: V = m*g*h\n    # For pendulum: h = l*(1 - cos(\u03b8)) (with reference at bottom)\n    potential_energy = mass * gravity * length * (1 - np.cos(theta))\n\n    # Lagrangian\n    lagrangian = kinetic_energy - potential_energy\n\n    return lagrangian, kinetic_energy, potential_energy\n\ndef equations_of_motion_1dof_pendulum(theta, theta_dot, mass, length, gravity=9.81):\n    """\n    Derive equations of motion for 1-DOF pendulum using Lagrangian method\n    Returns: \u03b8_ddot (angular acceleration)\n    """\n    # The equation of motion for a simple pendulum is:\n    # \u03b8_ddot = -(g/l)*sin(\u03b8)\n    theta_ddot = -(gravity / length) * np.sin(theta)\n\n    return theta_ddot\n\n# Example: Calculate Lagrangian and equation of motion\nlag, T, V = lagrangian_1dof_pendulum(theta, theta_dot, mass, length)\ntheta_ddot_calc = equations_of_motion_1dof_pendulum(theta, theta_dot, mass, length)\n\nprint(f"Lagrangian: {lag:.3f} J")\nprint(f"Kinetic Energy: {T:.3f} J")\nprint(f"Potential Energy: {V:.3f} J")\nprint(f"Angular acceleration: {theta_ddot_calc:.3f} rad/s\xb2")\n'})}),"\n",(0,a.jsx)(e.h3,{id:"33-dynamic-model-for-multi-dof-manipulator",children:"3.3 Dynamic Model for Multi-DOF Manipulator"}),"\n",(0,a.jsx)(e.p,{children:"For multi-DOF manipulators, the dynamic equation is:"}),"\n",(0,a.jsx)(e.p,{children:"M(q)q\u0308 + C(q, q\u0307)q\u0307 + G(q) = \u03c4"}),"\n",(0,a.jsx)(e.p,{children:"Where:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"M(q) is the mass matrix"}),"\n",(0,a.jsx)(e.li,{children:"C(q, q\u0307) contains Coriolis and centrifugal terms"}),"\n",(0,a.jsx)(e.li,{children:"G(q) contains gravitational terms"}),"\n",(0,a.jsx)(e.li,{children:"\u03c4 is the vector of applied torques"}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'def mass_matrix_2dof(theta1, theta2, m1, m2, l1, l2):\n    """\n    Mass matrix for 2-DOF planar manipulator\n    """\n    # Simplified mass matrix calculation\n    # In a real implementation, this would involve more complex calculations\n    # based on the specific manipulator geometry and mass distribution\n\n    # Calculate intermediate values\n    c2 = np.cos(theta2)\n\n    # Mass matrix elements (simplified for demonstration)\n    M11 = m1*l1**2 + m2*(l1**2 + l2**2 + 2*l1*l2*c2)\n    M12 = m2*(l2**2 + l1*l2*c2)\n    M21 = M12\n    M22 = m2*l2**2\n\n    M = np.array([[M11, M12],\n                  [M21, M22]])\n\n    return M\n\ndef coriolis_matrix_2dof(theta1, theta2, theta1_dot, theta2_dot, m2, l1, l2):\n    """\n    Coriolis matrix for 2-DOF planar manipulator\n    """\n    # Simplified Coriolis matrix calculation\n    s2 = np.sin(theta2)\n\n    C11 = -2*m2*l1*l2*theta2_dot*s2\n    C12 = -m2*l1*l2*theta2_dot*s2\n    C21 = m2*l1*l2*theta1_dot*s2\n    C22 = 0\n\n    C = np.array([[C11, C12],\n                  [C21, C22]])\n\n    return C\n\ndef gravity_vector_2dof(theta1, theta2, m1, m2, l1, l2, g=9.81):\n    """\n    Gravity vector for 2-DOF planar manipulator\n    """\n    g1 = (m1 + m2)*g*l1*np.cos(theta1) + m2*g*l2*np.cos(theta1 + theta2)\n    g2 = m2*g*l2*np.cos(theta1 + theta2)\n\n    return np.array([g1, g2])\n\n# Example: Calculate dynamic components\nm1, m2 = 1.0, 0.8  # masses\ntheta1, theta2 = np.pi/4, np.pi/6\ntheta1_dot, theta2_dot = 0.5, 0.3\n\nM = mass_matrix_2dof(theta1, theta2, m1, m2, l1, l2)\nC = coriolis_matrix_2dof(theta1, theta2, theta1_dot, theta2_dot, m2, l1, l2)\nG = gravity_vector_2dof(theta1, theta2, m1, m2, l1, l2)\n\nprint(f"Mass matrix:\\n{M}")\nprint(f"Coriolis matrix:\\n{C}")\nprint(f"Gravity vector: {G}")\n'})}),"\n",(0,a.jsx)(e.h2,{id:"4-control-theory-fundamentals",children:"4. Control Theory Fundamentals"}),"\n",(0,a.jsx)(e.p,{children:"Control theory provides the mathematical framework for controlling robotic motion."}),"\n",(0,a.jsx)(e.h3,{id:"41-pid-control",children:"4.1 PID Control"}),"\n",(0,a.jsx)(e.p,{children:"Proportional-Integral-Derivative control is widely used in robotics."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'class PIDController:\n    def __init__(self, kp, ki, kd, dt=0.01):\n        self.kp = kp  # Proportional gain\n        self.ki = ki  # Integral gain\n        self.kd = kd  # Derivative gain\n        self.dt = dt  # Time step\n\n        self.prev_error = 0\n        self.integral = 0\n\n    def update(self, error):\n        # Proportional term\n        p_term = self.kp * error\n\n        # Integral term\n        self.integral += error * self.dt\n        i_term = self.ki * self.integral\n\n        # Derivative term\n        derivative = (error - self.prev_error) / self.dt\n        d_term = self.kd * derivative\n\n        # Store current error for next iteration\n        self.prev_error = error\n\n        # Calculate output\n        output = p_term + i_term + d_term\n        return output\n\n# Example: PID control for position tracking\npid = PIDController(kp=10.0, ki=0.5, kd=2.0, dt=0.01)\n\n# Simulate a simple control scenario\ntarget_position = 1.0\ncurrent_position = 0.0\ndt = 0.01\n\nfor t in np.arange(0, 2, dt):  # 2 seconds of simulation\n    error = target_position - current_position\n\n    # Apply control (simplified - in reality this would affect system dynamics)\n    control_effort = pid.update(error)\n\n    # Update position based on control effort (simplified model)\n    current_position += control_effort * dt\n\n    if t % 0.5 < dt:  # Print every 0.5 seconds\n        print(f"Time: {t:.2f}s, Position: {current_position:.3f}, Error: {error:.3f}")\n\nprint(f"Final position: {current_position:.3f}, Target: {target_position}")\n'})}),"\n",(0,a.jsx)(e.h2,{id:"5-pybullet-examples-for-kinematics-and-dynamics",children:"5. PyBullet Examples for Kinematics and Dynamics"}),"\n",(0,a.jsx)(e.p,{children:"Let's implement some kinematic and dynamic examples using PyBullet."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import pybullet as p\nimport pybullet_data\nimport time\nimport numpy as np\n\ndef setup_kinematics_demo():\n    """Set up PyBullet environment for kinematics demonstration"""\n    # Connect to PyBullet\n    physicsClient = p.connect(p.GUI)\n\n    # Set gravity\n    p.setGravity(0, 0, -9.81)\n\n    # Load plane\n    p.setAdditionalSearchPath(pybullet_data.getDataPath())\n    planeId = p.loadURDF("plane.urdf")\n\n    return physicsClient\n\ndef demo_inverse_kinematics():\n    """Demonstrate inverse kinematics using PyBullet\'s built-in IK solver"""\n    # Set up environment\n    physicsClient = setup_kinematics_demo()\n\n    # Load a simple robot (KUKA LBR iiwa)\n    robotId = p.loadURDF("kuka_iiwa/model.urdf", [0, 0, 0])\n\n    # Define target position for end-effector\n    target_position = [0.5, 0.2, 0.3]\n    target_orientation = p.getQuaternionFromEuler([0, 0, 0])\n\n    # Solve inverse kinematics\n    joint_angles = p.calculateInverseKinematics(\n        robotId,\n        endEffectorLinkIndex=6,  # iiwa has 7 joints, index 6 is the end effector\n        targetPosition=target_position,\n        targetOrientation=target_orientation\n    )\n\n    # Apply the joint angles to the robot\n    for i in range(len(joint_angles)):\n        p.resetJointState(robotId, i, joint_angles[i])\n\n    # Run simulation briefly to visualize\n    for i in range(300):\n        p.stepSimulation()\n        time.sleep(1./240.)\n\n    p.disconnect()\n\n# Note: This example would run in an environment with PyBullet installed\nprint("PyBullet inverse kinematics demo defined - requires PyBullet installation to run")\n'})}),"\n",(0,a.jsx)(e.h2,{id:"6-kinematics-and-dynamics-exercises",children:"6. Kinematics and Dynamics Exercises"}),"\n",(0,a.jsx)(e.h3,{id:"exercise-1-forward-kinematics-implementation",children:"Exercise 1: Forward Kinematics Implementation"}),"\n",(0,a.jsx)(e.p,{children:"Implement forward kinematics for a 3-DOF planar manipulator."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'def forward_kinematics_3dof(theta1, theta2, theta3, l1, l2, l3):\n    """\n    Forward kinematics for 3-DOF planar manipulator\n    Calculate end-effector position given joint angles\n    """\n    # Calculate end-effector position using trigonometry\n    x = l1*np.cos(theta1) + l2*np.cos(theta1 + theta2) + l3*np.cos(theta1 + theta2 + theta3)\n    y = l1*np.sin(theta1) + l2*np.sin(theta1 + theta2) + l3*np.sin(theta1 + theta2 + theta3)\n\n    return np.array([x, y])\n\n# Test the function\nl1, l2, l3 = 1.0, 0.8, 0.6\ntheta1, theta2, theta3 = np.pi/4, np.pi/6, np.pi/8\n\nend_pos = forward_kinematics_3dof(theta1, theta2, theta3, l1, l2, l3)\nprint(f"3-DOF end-effector position: {end_pos}")\n'})}),"\n",(0,a.jsx)(e.h3,{id:"exercise-2-simple-dynamic-simulation",children:"Exercise 2: Simple Dynamic Simulation"}),"\n",(0,a.jsx)(e.p,{children:"Create a simple dynamic simulation for a single joint."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'def simulate_single_joint_dynamics(torque, initial_position, initial_velocity,\n                                  mass, length, gravity=9.81, dt=0.01, duration=2.0):\n    """\n    Simulate the dynamics of a single joint pendulum\n    """\n    # Moment of inertia for point mass at end of rod\n    inertia = mass * length**2\n\n    # Initialize state\n    theta = initial_position\n    theta_dot = initial_velocity\n\n    # Time vector\n    time_steps = np.arange(0, duration, dt)\n    positions = []\n    velocities = []\n\n    for t in time_steps:\n        # Calculate angular acceleration using equation of motion\n        # For pendulum: I*\u03b8_ddot = \u03c4 - m*g*l*sin(\u03b8)\n        theta_ddot = (torque - mass * gravity * length * np.sin(theta)) / inertia\n\n        # Update state using Euler integration\n        theta_dot += theta_ddot * dt\n        theta += theta_dot * dt\n\n        # Store values\n        positions.append(theta)\n        velocities.append(theta_dot)\n\n    return time_steps, np.array(positions), np.array(velocities)\n\n# Example simulation\ntime_vals, pos_vals, vel_vals = simulate_single_joint_dynamics(\n    torque=0.5,  # N\xb7m\n    initial_position=np.pi/6,  # 30 degrees\n    initial_velocity=0.1,  # rad/s\n    mass=1.0,\n    length=1.0,\n    dt=0.01,\n    duration=5.0\n)\n\nprint(f"Simulated {len(time_vals)} time steps")\nprint(f"Final position: {pos_vals[-1]:.3f} rad, Final velocity: {vel_vals[-1]:.3f} rad/s")\n'})}),"\n",(0,a.jsx)(e.h2,{id:"7-summary",children:"7. Summary"}),"\n",(0,a.jsx)(e.p,{children:"This chapter covered the fundamental concepts of kinematics and dynamics for robotic systems:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Forward Kinematics"}),": Determining end-effector position from joint angles using DH parameters and transformation matrices"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Inverse Kinematics"}),": Finding joint angles for desired end-effector positions using analytical and numerical methods"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Robot Dynamics"}),": Understanding forces and torques that cause motion using Newton-Euler and Lagrangian formulations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Control Theory"}),": Basic control methods like PID for managing robot motion"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Practical Implementation"}),": Using PyBullet for kinematic and dynamic simulation"]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"These concepts are essential for understanding how robots move and how to control their motion effectively. The mathematical models developed in this chapter form the foundation for more advanced topics in robotics and Physical AI."}),"\n",(0,a.jsx)(e.h2,{id:"8-implementation-guide",children:"8. Implementation Guide"}),"\n",(0,a.jsx)(e.p,{children:"To implement the kinematic and dynamic concepts covered in this chapter:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Practice deriving DH parameters for different manipulator configurations"}),"\n",(0,a.jsx)(e.li,{children:"Implement forward and inverse kinematics solvers for simple manipulators"}),"\n",(0,a.jsx)(e.li,{children:"Work with dynamic models to simulate robot motion"}),"\n",(0,a.jsx)(e.li,{children:"Apply control theory concepts to stabilize robot movements"}),"\n",(0,a.jsx)(e.li,{children:"Use PyBullet to visualize and validate kinematic and dynamic calculations"}),"\n",(0,a.jsx)(e.li,{children:"Experiment with different control parameters to understand their effects"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"The exercises provided offer hands-on practice with these fundamental concepts, preparing readers for more advanced topics in robotics and Physical AI."})]})}function m(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(c,{...n})}):c(n)}},8453(n,e,t){t.d(e,{R:()=>r,x:()=>s});var i=t(6540);const a={},o=i.createContext(a);function r(n){const e=i.useContext(o);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:r(n.components),i.createElement(o.Provider,{value:e},n.children)}}}]);