"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[7151],{8453(e,n,i){i.d(n,{R:()=>t,x:()=>r});var s=i(6540);const a={},o=s.createContext(a);function t(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),s.createElement(o.Provider,{value:n},e.children)}},9380(e,n,i){i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>t,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-3-digital-twin/chapter-1-gazebo-basics/content","title":"Gazebo Simulation Environment Setup","description":"Learning Objectives","source":"@site/docs/module-3-digital-twin/chapter-1-gazebo-basics/content.md","sourceDirName":"module-3-digital-twin/chapter-1-gazebo-basics","slug":"/module-3-digital-twin/chapter-1-gazebo-basics/content","permalink":"/Physicial_Ai_Book_Hackathon_1/docs/module-3-digital-twin/chapter-1-gazebo-basics/content","draft":false,"unlisted":false,"editUrl":"https://github.com/shirazkk/Physicial_Ai_Book_Hackathon_1/edit/main/my-website/docs/module-3-digital-twin/chapter-1-gazebo-basics/content.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Solutions: Implementing Robotic Nervous System Patterns","permalink":"/Physicial_Ai_Book_Hackathon_1/docs/module-2-robotic-nervous-system/chapter-4/solutions"},"next":{"title":"Gazebo Simulation Environment Setup - Exercises","permalink":"/Physicial_Ai_Book_Hackathon_1/docs/module-3-digital-twin/chapter-1-gazebo-basics/exercises"}}');var a=i(4848),o=i(8453);const t={},r="Gazebo Simulation Environment Setup",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Introduction",id:"introduction",level:2},{value:"1. Installing and Configuring Gazebo Garden",id:"1-installing-and-configuring-gazebo-garden",level:2},{value:"1.1 Gazebo Garden Installation",id:"11-gazebo-garden-installation",level:3},{value:"1.2 Gazebo Physics Engine Configuration",id:"12-gazebo-physics-engine-configuration",level:3},{value:"1.3 Key Physics Parameters",id:"13-key-physics-parameters",level:3},{value:"2. Creating Basic World Files",id:"2-creating-basic-world-files",level:2},{value:"2.1 World File Structure",id:"21-world-file-structure",level:3},{value:"2.2 Customizing Environments",id:"22-customizing-environments",level:3},{value:"3. Spawning Robots in Gazebo",id:"3-spawning-robots-in-gazebo",level:2},{value:"3.1 Basic Robot Spawning",id:"31-basic-robot-spawning",level:3},{value:"3.2 Programmatic Robot Spawning with ROS 2",id:"32-programmatic-robot-spawning-with-ros-2",level:3},{value:"4. World Customization Techniques",id:"4-world-customization-techniques",level:2},{value:"4.1 Creating Obstacle Courses",id:"41-creating-obstacle-courses",level:3},{value:"4.2 Terrain Generation",id:"42-terrain-generation",level:3},{value:"5. Simulation Validation",id:"5-simulation-validation",level:2},{value:"5.1 Physics Accuracy Verification",id:"51-physics-accuracy-verification",level:3},{value:"5.2 Performance Optimization",id:"52-performance-optimization",level:3},{value:"6. Practical Example: Setting Up a Basic Humanoid Testing Environment",id:"6-practical-example-setting-up-a-basic-humanoid-testing-environment",level:2},{value:"7. Summary",id:"7-summary",level:2},{value:"8. Exercises and Practice",id:"8-exercises-and-practice",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"gazebo-simulation-environment-setup",children:"Gazebo Simulation Environment Setup"})}),"\n",(0,a.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,a.jsx)(n.p,{children:"By the end of this chapter, readers will be able to:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Configure Gazebo simulation environments with appropriate physics parameters"}),"\n",(0,a.jsx)(n.li,{children:"Create and customize world models for robot testing"}),"\n",(0,a.jsx)(n.li,{children:"Understand the relationship between simulation parameters and real-world physics"}),"\n",(0,a.jsx)(n.li,{children:"Set up basic robot models in Gazebo simulation environment"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Completion of Module 1: Foundations of Physical AI & Humanoid Robotics"}),"\n",(0,a.jsx)(n.li,{children:"Completion of Module 2: Robotic Nervous System"}),"\n",(0,a.jsx)(n.li,{children:"Basic understanding of ROS/ROS 2 concepts"}),"\n",(0,a.jsx)(n.li,{children:"Fundamental knowledge of robot kinematics and dynamics"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(n.p,{children:"Gazebo is a powerful 3D simulation environment that plays a critical role in robotics development. It provides realistic physics simulation, high-quality rendering, and convenient programmatic interfaces. For humanoid robotics development, Gazebo serves as a safe, cost-effective environment where complex robot behaviors can be tested without risk to physical hardware."}),"\n",(0,a.jsx)(n.p,{children:"This chapter focuses on setting up Gazebo simulation environments specifically tailored for humanoid robotics applications. We'll explore the physics engine parameters, world creation techniques, and best practices for creating realistic simulation environments."}),"\n",(0,a.jsx)(n.h2,{id:"1-installing-and-configuring-gazebo-garden",children:"1. Installing and Configuring Gazebo Garden"}),"\n",(0,a.jsx)(n.h3,{id:"11-gazebo-garden-installation",children:"1.1 Gazebo Garden Installation"}),"\n",(0,a.jsx)(n.p,{children:"Gazebo Garden (Harmonic) is the latest stable version with ongoing support and is fully compatible with ROS 2 Humble Hawksbill. To install Gazebo Garden, follow these steps:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# Add Gazebo repository\ncurl -sSL http://get.gazebosim.org | sh\n\n# Install Gazebo Garden\nsudo apt-get install gz-harmonic\n"})}),"\n",(0,a.jsx)(n.p,{children:"After installation, verify that Gazebo is properly installed by running:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"gz --version\n"})}),"\n",(0,a.jsx)(n.h3,{id:"12-gazebo-physics-engine-configuration",children:"1.2 Gazebo Physics Engine Configuration"}),"\n",(0,a.jsx)(n.p,{children:"Gazebo supports multiple physics engines including ODE, Bullet, and DART. For humanoid robotics simulation, we recommend using the ODE (Open Dynamics Engine) physics engine due to its stability and accuracy for legged locomotion."}),"\n",(0,a.jsxs)(n.p,{children:["The physics engine is configured in the world file using the ",(0,a.jsx)(n.code,{children:"<physics>"})," tag:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:"<sdf version='1.7'>\n  <world name='humanoid_world'>\n    \x3c!-- Physics Engine Configuration --\x3e\n    <physics type='ode'>\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000.0</real_time_update_rate>\n      <gravity>0 0 -9.8</gravity>\n    </physics>\n\n    \x3c!-- Rest of the world definition --\x3e\n  </world>\n</sdf>\n"})}),"\n",(0,a.jsx)(n.h3,{id:"13-key-physics-parameters",children:"1.3 Key Physics Parameters"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"max_step_size"}),": The maximum time step size for the physics engine. Smaller values provide more accurate simulation but require more computation. For humanoid robotics, 0.001 seconds is recommended."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"real_time_factor"}),": The target factor at which the simulation should run in relation to real time. A value of 1.0 means the simulation should run at real-time speed."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"real_time_update_rate"}),": The rate at which the physics engine updates. Higher values provide smoother simulation."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"gravity"}),": The gravitational acceleration vector (x, y, z) in m/s\xb2. Earth's gravity is approximately 9.8 m/s\xb2 downward."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"2-creating-basic-world-files",children:"2. Creating Basic World Files"}),"\n",(0,a.jsx)(n.h3,{id:"21-world-file-structure",children:"2.1 World File Structure"}),"\n",(0,a.jsx)(n.p,{children:"A Gazebo world file is an SDF (Simulation Description Format) file that defines the simulation environment. Here's a basic structure:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:"<?xml version=\"1.0\" ?>\n<sdf version='1.7'>\n  <world name='humanoid_basic_world'>\n    \x3c!-- Physics Engine --\x3e\n    <physics type='ode'>\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000.0</real_time_update_rate>\n      <gravity>0 0 -9.8</gravity>\n    </physics>\n\n    \x3c!-- Scene Configuration --\x3e\n    <scene>\n      <ambient>0.4 0.4 0.4 1</ambient>\n      <background>0.7 0.7 0.7 1</background>\n      <shadows>true</shadows>\n    </scene>\n\n    \x3c!-- Lighting --\x3e\n    <light name='sun' type='directional'>\n      <cast_shadows>true</cast_shadows>\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n      <specular>0.2 0.2 0.2 1</specular>\n      <attenuation>\n        <range>1000</range>\n        <constant>0.9</constant>\n        <linear>0.01</linear>\n        <quadratic>0.001</quadratic>\n      </attenuation>\n      <direction>-0.3 0.3 -1</direction>\n    </light>\n\n    \x3c!-- Ground Plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Sky --\x3e\n    <plugin filename=\"gz-sim-sky-spherical_coordinates-system\" name=\"gz::sim::systems::SkySphericalCoordinates\">\n      <time_daylight>12:00</time_daylight>\n      <sunrise>6:00</sunrise>\n      <sunset>18:00</sunset>\n    </plugin>\n  </world>\n</sdf>\n"})}),"\n",(0,a.jsx)(n.h3,{id:"22-customizing-environments",children:"2.2 Customizing Environments"}),"\n",(0,a.jsx)(n.p,{children:"World customization allows for creating diverse testing environments for humanoid robots. Key customization options include:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Terrain"}),": Creating uneven surfaces, ramps, stairs, or obstacles"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Objects"}),": Adding furniture, walls, or interactive elements"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Lighting"}),": Adjusting intensity, direction, and color of light sources"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Weather"}),": Simulating different atmospheric conditions"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"3-spawning-robots-in-gazebo",children:"3. Spawning Robots in Gazebo"}),"\n",(0,a.jsx)(n.h3,{id:"31-basic-robot-spawning",children:"3.1 Basic Robot Spawning"}),"\n",(0,a.jsxs)(n.p,{children:["Robots can be spawned in Gazebo using the ",(0,a.jsx)(n.code,{children:"gz model"})," command or programmatically through ROS 2 services. Here's an example of spawning a robot from the command line:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# Spawn a robot model from a local file\ngz model -f /path/to/robot/model.sdf -m robot_name\n\n# Spawn a robot model from a gazebo model database\ngz model -m robot_name --model-name robot_instance_name -z 1.0\n"})}),"\n",(0,a.jsx)(n.h3,{id:"32-programmatic-robot-spawning-with-ros-2",children:"3.2 Programmatic Robot Spawning with ROS 2"}),"\n",(0,a.jsx)(n.p,{children:"Using ROS 2, robots can be spawned programmatically:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_srvs.srv import Trigger\nfrom gazebo_msgs.srv import SpawnEntity\n\nclass RobotSpawner(Node):\n    def __init__(self):\n        super().__init__('robot_spawner')\n        self.spawn_client = self.create_client(SpawnEntity, '/spawn_entity')\n\n        while not self.spawn_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Spawn service not available, waiting again...')\n\n    def spawn_robot(self, robot_xml, robot_name, initial_pose):\n        request = SpawnEntity.Request()\n        request.xml = robot_xml\n        request.name = robot_name\n        request.initial_pose = initial_pose\n\n        future = self.spawn_client.call_async(request)\n        rclpy.spin_until_future_complete(self, future)\n\n        if future.result() is not None:\n            self.get_logger().info(f'Successfully spawned {robot_name}')\n        else:\n            self.get_logger().error(f'Failed to spawn {robot_name}')\n\ndef main():\n    rclpy.init()\n    spawner = RobotSpawner()\n\n    # Example: spawn a simple box robot\n    robot_xml = \"\"\"\n    <sdf version='1.7'>\n      <model name='simple_box_robot'>\n        <link name='chassis'>\n          <pose>0 0 0.1 0 0 0</pose>\n          <collision name='collision'>\n            <geometry>\n              <box>\n                <size>0.5 0.5 0.2</size>\n              </box>\n            </geometry>\n          </collision>\n          <visual name='visual'>\n            <geometry>\n              <box>\n                <size>0.5 0.5 0.2</size>\n              </box>\n            </geometry>\n          </visual>\n          <inertial>\n            <mass>1.0</mass>\n            <inertia>\n              <ixx>0.01</ixx>\n              <iyy>0.01</iyy>\n              <izz>0.01</izz>\n              <ixy>0</ixy>\n              <ixz>0</ixz>\n              <iyz>0</iyz>\n            </inertia>\n          </inertial>\n        </link>\n      </model>\n    </sdf>\n    \"\"\"\n\n    initial_pose = ...\n    spawner.spawn_robot(robot_xml, 'simple_box_robot', initial_pose)\n\n    rclpy.spin(spawner)\n    spawner.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsx)(n.h2,{id:"4-world-customization-techniques",children:"4. World Customization Techniques"}),"\n",(0,a.jsx)(n.h3,{id:"41-creating-obstacle-courses",children:"4.1 Creating Obstacle Courses"}),"\n",(0,a.jsx)(n.p,{children:"For humanoid robotics testing, creating obstacle courses helps evaluate locomotion and navigation capabilities:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:"\x3c!-- Example: Simple obstacle course --\x3e\n<model name='obstacle_1'>\n  <pose>2 0 0.1 0 0 0</pose>\n  <link name='link'>\n    <collision name='collision'>\n      <geometry>\n        <box>\n          <size>0.2 2.0 0.5</size>\n        </box>\n      </geometry>\n    </collision>\n    <visual name='visual'>\n      <geometry>\n        <box>\n          <size>0.2 2.0 0.5</size>\n        </box>\n      </geometry>\n      <material>\n        <ambient>1 0 0 1</ambient>\n        <diffuse>1 0 0 1</diffuse>\n      </material>\n    </visual>\n  </link>\n</model>\n"})}),"\n",(0,a.jsx)(n.h3,{id:"42-terrain-generation",children:"4.2 Terrain Generation"}),"\n",(0,a.jsx)(n.p,{children:"For more complex terrain, you can create heightmaps or use procedural generation techniques. Gazebo supports various terrain types including flat planes, heightmaps, and custom meshes."}),"\n",(0,a.jsx)(n.h2,{id:"5-simulation-validation",children:"5. Simulation Validation"}),"\n",(0,a.jsx)(n.h3,{id:"51-physics-accuracy-verification",children:"5.1 Physics Accuracy Verification"}),"\n",(0,a.jsx)(n.p,{children:"To verify that the simulation physics accurately represent real-world behavior:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Gravity validation"}),": Drop objects and measure fall time to verify gravitational acceleration"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Collision detection"}),": Test object interactions to ensure proper collision handling"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Friction modeling"}),": Validate friction coefficients by testing sliding behaviors"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"52-performance-optimization",children:"5.2 Performance Optimization"}),"\n",(0,a.jsx)(n.p,{children:"For smooth simulation performance:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Keep triangle counts reasonable for meshes"}),"\n",(0,a.jsx)(n.li,{children:"Use appropriate physics update rates"}),"\n",(0,a.jsx)(n.li,{children:"Limit the number of active sensors"}),"\n",(0,a.jsx)(n.li,{children:"Optimize rendering settings based on hardware capabilities"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"6-practical-example-setting-up-a-basic-humanoid-testing-environment",children:"6. Practical Example: Setting Up a Basic Humanoid Testing Environment"}),"\n",(0,a.jsx)(n.p,{children:"Let's create a complete example of a basic humanoid testing environment:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:"<?xml version=\"1.0\" ?>\n<sdf version='1.7'>\n  <world name='humanoid_test_world'>\n    \x3c!-- Physics Configuration --\x3e\n    <physics type='ode'>\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000.0</real_time_update_rate>\n      <gravity>0 0 -9.8</gravity>\n    </physics>\n\n    \x3c!-- Scene Settings --\x3e\n    <scene>\n      <ambient>0.3 0.3 0.3 1</ambient>\n      <background>0.6 0.6 0.6 1</background>\n      <shadows>true</shadows>\n    </scene>\n\n    \x3c!-- Lighting --\x3e\n    <light name='sun' type='directional'>\n      <cast_shadows>true</cast_shadows>\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n      <specular>0.2 0.2 0.2 1</specular>\n      <direction>-0.3 0.3 -1</direction>\n    </light>\n\n    \x3c!-- Ground Plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Simple Ramp for Testing --\x3e\n    <model name='ramp'>\n      <pose>3 0 0 0 0.2 0</pose>\n      <link name='link'>\n        <collision name='collision'>\n          <geometry>\n            <mesh>\n              <uri>file://meshes/ramp.dae</uri>\n            </mesh>\n          </geometry>\n        </collision>\n        <visual name='visual'>\n          <geometry>\n            <mesh>\n              <uri>file://meshes/ramp.dae</uri>\n            </mesh>\n          </geometry>\n          <material>\n            <ambient>0.5 0.5 0.5 1</ambient>\n            <diffuse>0.7 0.7 0.7 1</diffuse>\n          </material>\n        </visual>\n      </link>\n    </model>\n\n    \x3c!-- Obstacle Course --\x3e\n    <model name='stepping_stone_1'>\n      <pose>5 0 0.05 0 0 0</pose>\n      <link name='link'>\n        <collision name='collision'>\n          <geometry>\n            <cylinder>\n              <radius>0.3</radius>\n              <length>0.1</length>\n            </cylinder>\n          </geometry>\n        </collision>\n        <visual name='visual'>\n          <geometry>\n            <cylinder>\n              <radius>0.3</radius>\n              <length>0.1</length>\n            </cylinder>\n          </geometry>\n          <material>\n            <ambient>0.8 0.6 0.2 1</ambient>\n            <diffuse>0.8 0.6 0.2 1</diffuse>\n          </material>\n        </visual>\n      </link>\n    </model>\n  </world>\n</sdf>\n"})}),"\n",(0,a.jsx)(n.h2,{id:"7-summary",children:"7. Summary"}),"\n",(0,a.jsx)(n.p,{children:"This chapter introduced the fundamentals of setting up Gazebo simulation environments for humanoid robotics. We covered:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Installing and configuring Gazebo Garden with appropriate physics parameters"}),"\n",(0,a.jsx)(n.li,{children:"Creating and customizing world files for robot testing"}),"\n",(0,a.jsx)(n.li,{children:"Spawning robots programmatically and through command-line tools"}),"\n",(0,a.jsx)(n.li,{children:"World customization techniques for diverse testing scenarios"}),"\n",(0,a.jsx)(n.li,{children:"Simulation validation and performance optimization"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"With a properly configured Gazebo environment, you can now proceed to model humanoid robots with appropriate physics properties and joint constraints, which will be covered in the next chapter."}),"\n",(0,a.jsx)(n.h2,{id:"8-exercises-and-practice",children:"8. Exercises and Practice"}),"\n",(0,a.jsx)(n.p,{children:"Complete the following exercises to reinforce your understanding of Gazebo simulation environment setup:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/Physicial_Ai_Book_Hackathon_1/docs/module-3-digital-twin/chapter-1-gazebo-basics/exercises",children:"Chapter 1 Exercises"})," - Practice problems covering Gazebo environment creation and customization"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/Physicial_Ai_Book_Hackathon_1/docs/module-3-digital-twin/chapter-1-gazebo-basics/solutions",children:"Chapter 1 Solutions"})," - Complete implementations and solution guides"]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);